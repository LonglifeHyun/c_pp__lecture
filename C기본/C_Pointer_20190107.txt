C_Pointer_2019.01.07

기초이론3 - C언어 포인터 Part2

p3
char s[] = "abc";		// s : 배열, "abc" : initializer
char* p = "abc";		// p : 포인터 , "abc" : 문자열상수(배열)

printf("%p %s \n", s, s);	// s --> &s[0] 이므로 %s 의 대응 타입은 char* 임.
printf("%p %s \n", p, p);	// %p 정수를 16진수로 출력. 일반 정수 출력에 활용해도 되지만, 일반적으로 주소값을 출력할 때 사용. 
			  %p는 임의의 포인터 타입에 대응.

# 문자열의 첫 주소값만 주면 문자열 전체가 출력될 수 있는 이유는?
	(비유)성국이 삼형제 예시. 항상 연속으로 저장되어 있으므로 첫째인 성국이의 위치만 파악하면 됨.

#include <stdio.h>

void f(char* s)	//배열 요소 포인터
{
	for(i=0;is[i]!='\0';++i)
		putchar(s[i]);
}

int main(void)
{
	char s[] = "abc";
	f(s);	//  f(&s[0]);
	printf("%s",s);
	return 0;
}
----------------------------------------------------------------------------------------------------------------------------------
p4

# RE의 원인
	1) Divided by Zero	# 성국이가 별을 따달라고 하는 것.
	2) Memory access violation --> 보안문제와 직결됨	# 성국이가 수현이 책상에서 커피를 가져가는 것.
 ==> 운영체제가 프로세스를 죽여버림.

문자열 s는 해당 프로그램에 할당된 메모리 영역 안에 있음. p도 마찬가지.
그런데, 초기화가 되지 않음. --> 쓰레기값이 들어가있음.
이 쓰레기 값이 할당된 메모리 내부 영역인지, 외부 영역인지 알 수 없음.
--> 재수 진짜 없으면 RE 발생, 아니면 LE이거나 no error. 
--> 메모리 전체에 비해 프로그램에 할당된 메모리영역은 극도로 작기 때문에 RE의 확률이 높다
	(앞에서 배웠던 dangling pointer 의 경우 이와 다르게 발생확률이 낮음)

# 이제 코드 딱보면 RE 발생 확률 정도는 알아야 함.

< 프로그램에서 에러에 대한 확률 >

발생확률	발견확률	출시후 발생 확률
------------------------------------------------
  0%		   0%		    0%
  1%		   1%		    99%		--> 제일 위험한 상황. 같은 RE이더라도 발견확률이 낮을수록 위험.
  .		   .		    .
  .		   .		    .
  .		   .		    .
  99%		   99%		    1%
  100%		   100%		    0%

확률이 아아아아아주 작을때 더 위험해짐.
(비유) 
가끔씩 전화가 잘 안됨. 하필 안됐을 때 중요한 사업을 놓침. A/S센터가면 잘되기 때문에 바로 고칠수가 없음.
자주 전화가 잘 안됨. 그럼 바로 고칠 수 있음.

발생 빈도가 작으면 작을수록 수정될 확률이 떨어지므로 더 위험.
그래서 dangling pointer의 에러가 더 위험할지도 모른다.

p5
[문자열 상수]
s1 ~ s4 : 포인터 // 전부 첫요주로 타입변환

(ex)
case1. p1~p4가 각각 다른 메모리 공간을 가리키고 있음.
p1	-->	abcde\0
p2	-->	abcde\0		// p2[3] = 'x';
p3	-->	abcde\0
p4	-->	abcde\0

printf(p1) : abcde;
printf(p2) : abxde;
printf(p3) : abcde;
printf(p4) : abcde;
---------------------------------------------------------------------------------------
case2. p1 ~ p4 가 모두 같은 메모리 공간을 가리키고 있음.
p1,p2,p3,p4	-->	abcde\0  // p2[3] = 'x';

printf(p1) : abcde;
printf(p2) : abcde;
printf(p3) : abcde;
printf(p4) : abcde;

p2는 바뀌어야 하고 나머지는 그대로여야 하므로 case1이 좀 더 일반적이고 상식적임.


그런데 '절대 값을 바꾸지 않을 것이다.' 라는 경우에는 case2로 구현하는 것이 좀 더 효과적.
문자열 상수는 값이 바뀌지 않음. 따라서 case2로 구현
--> 메모리 낭비를 줄임.

==> p5의 위의 경우엔 case2(s1~s4). 밑의 경우엔 case1.(s5,s6)로 구현해 놓은 소스코드.

컴파일러가 둘 다 할 수 있음. 프로그래머에게 물음. 
프로그래머가 따로 옵션을 주지 않으면 일반적으로 컴파일러는 case2.를 따름

*그러므로 같은 메모리 공간을 가리키고 있다고 가정하고 코딩하는 것은 바람직하지 못하다.

# 문자열 상수(s1~s4)는 메모리공간임에도 불구하고 이름이 없다. 

p7
배열의 길이 & 문자열의 길이 정의를 그냥 외울 것. 

다음의 소스코드도 외울 것.

#include <stdio.h>

int main(void)
{
	char a[10] = {'a','b','c','d','\0'};
	int i, len;
	
	for(i=0;a[i]!='\0';++i)
		;
	printf("string length == %d\n", i);
	
	len = sizeof(a)/sizeof(a[0]);
	printf("array length == %d\n", len);
	
	return 0;
}

for문 뒤에 그냥 ;이 옴 --> Null statement.

< i==4가 가지는 중의적 의미 >
1) '\0'의 위치
2) '\0' 앞의 문자 개수 == 문자열 길이

--> 문자열 길이 구할때 for문 구하면 된다.

배열 길이는 배열길이연산을 이용해서 구한다.

p8 ~
[2차원 배열]
C언어에서는 이차원 배열이 따로 없음.
구성요소가 곧 일차원 배열이 되는 배열을 이차원 배열이라 함.

int a[2][3];	// T(a) int[3][2] a;	: int[3]을 요소로 2개 가지는 배열.
행렬을 표현하기에 적합한 자료구조.

#include <stdio.h>

int main(void)
{
	int a[2][3] = {
		{1,2,3},
		{4,5,6}
	};
	int row, col;
	
	for(row=0;row<2;++row){
		for(col=0;col<3;++col)
			printf("%d ", a[row][col] );
		printf("\n");
	}
	return 0;
}

p11

a[0][0] ~ a[1][2] : type == int
a[0] ~ a[1] : type == int[3]
a : type == int[3][2]

메모리 구조를 딱 그려놓고 이걸 절대 헷갈리지 마라. 헷갈리면 고수가 아니다.

p12
row : a의 직접적인 구성요소
col : a[0]의 직접적인 구성요소

# row는 a의 길이이고 2가 될 수 밖에 없네. 이걸 바로 알아야지. 생각하고 있으면 안됨.

p13

pa = &a; 	
pa는 a의 주소값을 저장함으로써 a를 가리킨다.
a는 배열, 따라서 pa는 배열포인터.

p14
이차원 배열을 일차원배열 * 2로 생각 
--> 배열의 묵시적타입 변환과 동일하게 변환

p = &a[0] = a;	//배열a의 구성요소인 a[0]의 주소를 가리키면서 a[0]를 가리킴.
==> p는 a의 배열요소포인터로서 자기가 마치 배열인 것처럼 사용가능.

p16
함수 정의부에 인자로 적힌 타입 int m[2][3]은 사실은 가짜. int m*[3]이 진짜.

p19
num == row * col : 단위요소의 개수

p20
a[0] = *(a+0)	: 정의
a[0] == *a
a[0][0] == **a 
--> 원리를 알고 외울 것.

p21
[2차원 배열의 1차원 배열 취급]

&a = 1000		// T(&a) == int[3][2]*
&a[0] = 1000		// T(&a[0]) == int[3]*
&a[0][0] = 1000		// T(&a[0][0]) == int*

--> 주소값은 같은데 Reference Type이 다르다. 

첫번째 단위요소의 주소값을 가리키게 되면,
일차원배열의 요소포인터로 사용하고 있음. 그러나 실제로 가리키는 대상은 2차원 배열임.
즉, 2차원 배열을 1차원 배열로 취급. 

<1차원으로 출력하는 코드>
#include <stdio.h>

int main(void)
{
	int a[2][3] = {
		{1,2,3},
		{4,5,6}
	};
	int *p = &a[0][0];
	int i;
	int num = sizeof(a)/sizeof(**a);
		
	for(i=0;i<num;++i)
		printf("%d ", p[i]);
	printf("\n");
	
	return 0;
}

--------------------------------------------
p22
<2차원으로 출력하는 코드>
#include <stdio.h>

int main(void)
{
	int a[2][3] = {
		{1,2,3},
		{4,5,6}
	};
	int* p = (int*) &a;	// 주소는 같은데 타입이 다르기 때문에 강제로 타입캐스팅해서 넣은 것임
	int i;
	int num = sizeof(a) / sizeof(a[0][0]);
	int row = sizeof(a) / sizeof(a[0]);
	int col = sizeof(a[0]) / sizeof(a[0][0]);
	
	for(i=0;i<num;++i){
		printf("%d ",p[i]);
		if((i+1)%col==0) printf("\n");
	}
	printf("\n");
	return 0;
}

*중요 _ 같은 표현 골라낼 줄 알아야 함. 

int* p = &a[0][0];	// best
int* p = (int*) &a;
int* p = (int*) &a[0];
	= &(*(a+0))[0];	// &(*a)[0]
	= &**a;
	= *a;	// 위에꺼 상쇄
	= &a[0][1]-1; 
	= (int*) (&a[1]-1); // RT의 크기만큼 덧셈, 뺄셈됨.
	= (int*) a;
	= a[0];
	= &*[0];

p23
[다차원 배열]
평면상에서 출력하는데에 한계가 있음.

p24
다차원배열을 사용하기 위해서는 요소포인터를 잘 다룰 줄 알아야함.
요소 포인터 --> 배열처럼 사용

에잇 딴생각해부렀으
왜 하필 묵시적 타입변환이 요소포인터 형태로 일어날까?
정하기 나름이었음. 아래 두 가지 case.
a->&a[0]  ,  X[N] -> X* 	: 배열요소포인터가 배열처럼 사용할 수 있기에 더 편했음.
a->&a  ,  X[N] -> X[N]* 	: 이걸 묵시적타입변환으로 정의 했으면 배열포인터형태로 불편하게 사용했을 것임.

p25
능숙해져야함.

p28
double a[2];

a[i] == *(a+i)
================================================

double a[3][2];

a[r][c] == X[c] == *(X+c) 	// X == a[r]로 치환
        == *(a[r]+c)
	== *(*(a+r)+c)
	== (*(a+r))[c]
	== ((a[r])[c])		// 복잡할 거 없이 그냥 두 개의 배열연산자가 결합된 형태임. 우선순위는 동일, 왼쪽에서부터 연산

주의!)  != *(a+r)[c]
	!= (*a+r+c)

* 같은건지 다른건지 골라낼 줄 알아야 함. --> 중요!

//3차원 배열도 정의 할 줄 알아야 함.
double a[4][3][2];

a[i][j][k]
== *(a[i][j]+k)
== (*(a[i]+j))[k]
== (*(a+i))[j][k]

== (*(*(a+i)+j))[k]
== *(*(a[i]+j)+k)
== *((*(a+i)[j]+k)
== *(*(*(a+i)+j)+k)

// 이요요요용 달국이가 오류 찾았숼~~~

===============================================================================================================================
다음시간에는 포인터 사용시 주의사항









