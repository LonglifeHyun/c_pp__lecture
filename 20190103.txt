2019.01.03

CPP 맛보기 - 기본기능 1편

p20
변수의 정의 : 값을 저장하는 메모리 공간

p21
일반 문장 다음에 선언이 오면 S.E --> C89
그러나 C99, C++98에서는 허용이 됨(선언도 일종의 문장이다)

p22
C89는 for문 안에서 변수 선언도 허용하지 않았으나 C++부터는 허용
이 때, 주의할 점) for문 안에서 선언된 변수는 for문을 탈출하면 사라짐
변수를 계속해서 사용하고 싶다면 for문 외부에 선언을 해야 함

p24
const 변수는 선언시에 반드시 초기화를 해야하고, 그 값을 변경하게 되면 ERROR
뒤에서 값을 변경할 수 없으므로 메모리가 할당될 때 초기화가 되어야 함
(선언할 때 초기화 == 메모리 공간이 할당될 때 초기화)

# 선언 : 메모리 공간이 할당됨

# 	수학			vs		컴퓨터 공학
변수 	변할 수 있는 값				메모리 공간
	상수 == 변하지 않는 값			값(상수) != 메모리공간

수학적 관점 : const변수가 말이 안됨 --> 상수라고 말을 해야함
컴퓨터 공학 관점 : a와 b는 둘 다 변수다. 값이 저장되는 메모리 공간이기 때문.

const int b; 의 경우 쓰레기 값이 저장된 채로 그 값이 바뀌지도 못하므로 SE로 처리

p25
a는 함수가 호출될 때 할당되고 동시에 초기화 되어야 하는 함수의 지역변수.
함수 내에서는 초기화가 불가능(인자로도 불가능, 초기화되고난 후 함수 호출)

p26
[교수님 판서]
const int a = 3;

T(a) == const int

const int의 의미 : 이 변수는 int 타입의 값을 저장할 수 있으며 한번 초기화한 후에는 값을 변경하는 것이 불가능하다. 
주의) "const int 타입의 값이 저장된다" 라는 뜻이 아님. int타입인데 값을 변경하는 것이 불가능한 것일뿐.
-----------------------------------------------------------------------------------------------------------------
T(3) == int
T(3) != const int

int x=0;	// T(x) == int, T(0) == int

const int a=x; 	// T(x) == int, T(a) == const int  / x에 저장되어있는 0이라는 값이 a에 저장됨
(비유) x라는 방 안에 있던 값을 a라는 방 안에 집어넣음 (a에 x를 저장한다는 것이 아님 : 방에 방을 넣을 수 없음)
그러므로 "a와 x의 타입이 다르다" 이딴 소리 하면 안됨. a에 저장되어야 할 값의 타입은 int이므로 T(L) == T(R) 이 성립

const int b=a; 	// b에 저장되어야 할 값의 타입 == int이므로 합당하다.

[assignment operator(=)의 문법적 규칙]
1) 변수 = 값
	y=3;	//ok
	x=y;	//error --> y가 값으로 바뀐다면 ok (메인메모리에서의 y의 값이 레지스터에 저장이 되어야 가능한 일)
2) T(L) == T(R)
3) 결과값 == 대입값

p27
T(pa) == const int*
RT(pa) == const int

[교수님 판서]
pointer의 기본 개념

1) 정의
	pointer: 주소(값)를 저장하는 변수 
	pointer는 대상의 주소값을 저장함으로써 대상을 가리킨다.
# 주소도 일종의 값임  --> 변수의 구성요소 == 주소값(L-value) + 저장값(R-value)
# L : left  ,  R : right
 x=y;	// y는 주소값과 저장값을 구성요소로 가짐. 이 때, y의 주소값은 중요치 않음. y의 저장값을 알아야 함.
	// x는 주소값과 저장값을 구성요소로 가짐. 이 때, x의 저장값은 중요치 않음. x의 주소값을 알아야 함.
	--> assignment의 왼쪽에서는 주소값이 중요. 오른쪽에서는 저장값이 중요
	==> 주소값 == L-value , 저장값 == R-value // 컴퓨터 공학에서 자주쓰는 용어

2) 선언
	Reference Type: 
(비유) 형진이를 가리키는 방법은 다양하다. ex) 주소, 학번, 이름, 손가락질 etc
	--> 그중에서 C언어에서는 pointer를 주소값으로 가리키는 것을 정의
-------------------------------------------------------------------------------------------------------------
[C언어 Pointer]
&마법돌을 저장값에 붙이면 주소로 변함
*마법모자를 주소값에 붙이면 저장값 그 자체로 변함

(비유)
형진이가 교수님의 집 주소를 저장하고 있음 --> 교수님을 가리키고 있음
길을 가다가 수현이를 만나서 수현이가 인사를 하는데 형진이가 장난을 치고싶음.
별표마법모자를 써버림. 교수님 그 자체가 됨. 교수님으로 변장을 하거나 위장을 한 것이 아님.

int a = 36;
int x;
int* y;

저장값을 저장하고 싶다면 x = a;
주소값을 저장하고 싶다면 y = &a;

# 주소값은 원래 프로그래머가 지정해줘야하는데 OS와 Compiler한테 시킴

pointer : 주소값을 저장하는 *변수 즉, 메모리 공간임. --> pointer변수 라는 말은 잘못된 표현임
	--> 포인터라는 개념을 확립하기 위해 매우 중요한 것임
# Dennis Riche가 정의해놓은 것임.
 	pointer는 변수이기 때문에 사용전에 선언을 먼저 해야함
int a;
int* pa;
pa = &a;	// "pa는 a의 주소값을 저장함으로써 a를 가리킨다." 라고 말할 것*

T(pa) == int*
RT(pa) == int	// RT(Reference Type) : 가리키는 대상의 타입. (*을 뗀다)
T(&a) == int*	// 원래 타입에 *을 추가
T(a) == int
PT(a) == int*	// PT(Pointer Type) : 자신을 가리키는 지칭자 즉, 포인터의 타입 (*을 붙임)
PT(pa) == int**
RT(a) == None 	// 뗄 *이 없음. 대상을 가리키는 포인터가 아니므로 RT가 없는 것이 당연.
T(*pa) == int 	// 원래 타입에서 *을 제거 

[이해를 바탕으로 외울 것]
RT는 *을 떼고 PT는 *을 붙인다. 
T(&a) == PT(a)
T(*pa) == RT(pa)

[포인터 연산자(&, *) 문법규칙]
& + 변수 == 주소값
* + 주소값 == 변수	// 일반적으로 연산자의 수식 결과는 값이어야하는데 예외적으로 변수가 되는 것들 4개 중 하나.
			// *연산자의 수식 결과가 값이 되면 SE
			// 결과로 변수 그 자체* 가 됨
ex)
	&a	// ok
	&3	// SE(Syntax Error). 주소를 가지고 있지 않아서 주소값이 추출될 수가 없음
(비유)
흡혈귀는 피를 먹어야 한다.
모니터를 물면 배가 부르지 않음. 모니터는 피가 없으므로
형진이를 물면 배가 부름. 형진이는 피를 가지고 있으므로

# 어렵지 않으면 포인터가 아니다.  -교수님
=============================================================================================================
다시 복귀 p27
T(a) == const int
T(b) == int
RT(pa) == const int	// pa가 가리키는 대상은 값이 바뀌지 않는다.
RT(pb) == int		// pb가 가리키는 대상은 값이 바뀐다.
T(&a) == const int*
T(&b) == int*
T(pa) == const int*
T(pb) == int*

*중요 - (비유)
여자친구가 없으면 만나는 여자를 바꾸어도 됨.
여자친구가 있으면 만나는 여자를 바꾸면 안됨.

예동이는 여자친구가 있는데 교수님은 없는 줄 알고 예동이에게 다른 여자를 소개시켜줌. 
교수님은 예동이 여자친구에게 멱살잡히고 난리남.

교수님은 const int인 예동이를 가리키고 있는 포인터임. 
*마법모자를 씌워서 여자를 소개시켜주면(값을 바꾸면) Syntax Error.

경준이는 여자친구가 없음(int). 여자를 소개받아도 됨. 
교수님이 경준이가 여자친구가 있는 줄 앎. 경준이가 const int인 줄 착각.
그래서 여자를 소개 안해줌(type miss match). 경준이가 서운하긴해도 교수님 멱살을 잡을 여자친구는 없음.

따라서,
pa = &b; 	// ok: int* -> const int*
pb = &a; 	// error: const int* -> int*
p28
bool type : 진리값을 사용하기 위해 별도로 만든 타입.
	zero는 false와 교환
	non-zero는  true와 교환 
# true는 1과 교환되는데 1이라고 가정하지 않고 코딩하는 것이 바람직

# 알아둘 것
boolalpha : true / false로 값을 표현
noboolalpha : true -> 1 / false -> 0 으로 값을 표현

p29
[4대 기본 연산자]
1) 산술 연산자
2) 관계 연산자
3) 논리 연산자
4) 대입 연산자

# CPU의 구성 요소 : CU(ALU와 Register제어), ALU(실제 일꾼), Register(보조역할)
데이터가 Register를 통해서 ALU로 전달됨. ALU가 연산
그러므로 4대 기본 연산자의 피연산자와 연산 결과값의 종류는 정수, 실수(, 진리값) 뿐
구조체나 배열은 사용 불가 (크기가 유동적으로 바뀌므로 Register에 저장될 수 있는 형태가 아님)

그러나 C++, C99 문법부터는 구조체에 대한 대입 연산자에 한해서만 허용해줌.

int i;
i = 3 >= 4; 	// SE는 발생하지 않지만 Old Style임. 촌티남. (비유) 교수님이 몸빼 바지 입고 나타나심
--> bool 타입 변수를 따로 만들어서 저장하도록 할 것.

double d;
d = 3.5 < 5.5; 	// true이므로 1.0이 저장되긴 하지만 매우 바람직하지 못함. (비유) 교수님이 짧은치마 입고 나타나심

bool b;
b = true > false; 	// true가 1과 교환되고 false가 0과 교환됨을 생각하면 가능은 하지만,
			// 진리값의 대소비교를 하는 것은 논리적으로 말이 안됨. 매우 바람직하지 못함.(tricky한 표현)

b = 3.5 || 5.5;		// 짧은치마
b = 3 && 5;		// 몸빼바지

p30
진리값에 관해서, 묵시적 타입변환으로 타입캐스팅 연산자가 자동으로 붙음. --> Old Style.

# bitwise 연산자의 피연산자의 타입은 정수.

p31
변수 선언 == 메모리 할당
타입 선언 != 메모리 할당

C+=에서는 struct 키워드 생략 가능

p32
C++에서부터 객체지향에서의 중요한 개념이기에 구조체 복사 기능을 추가함.

b = a; 는 실제로 다음과 같이 바뀌어서 컴파일 됨. --> 구조체 복사(개별적 복사)
b.d = a.d;
b.m = a.m;
b.y = a.y;

p33
s1은 p의 주소값을 저장함으로써 p를 가리키고 있다.
이 때, s2 = s1 으로 구조체복사를 하게 되면 s2도 p의 주소값을 복사해서 가지게 되므로 p를 가리키게 됨.

Shallow(얕은) Copy : 구조체 안에 포인터가 있을 때, 구조체 복사가 되면서 동일한 대상을 가리키게 되는 것.
		    단순히 주소만 복사됨
<--> Deep(깊은) Copy

s1과 가리키고있던 대상 proffessor가 사라짐
--> s2 가리키고 있던 대상이 사라지게 됨. dangling pointer --> Error

단순히 주소 복사가 아니라 s1 가리키고 있던 대상 자체를 복사해서 개별적으로 가리키게 해야함. 
대상까지 복사해야하므로 복사해야할 것이 늘어남. --> Deep Copy

(비유)
형진이가 커피를 마시고 있었음. 교수님 " 맛있겠다 "
--> 형진이가 다른컵에 반 따라줌 : Shallow Copy
--> 새 커피를 하나 사와서 줌 : Deep Copy

Shallow Copy는 side effect 발생 가능. (장단점 있음)

p34
전통적인 C언어에서는 CBV로 구조체 복사 불가능. --> call by address로 구조체 복사
C++에서는 call by value로 구조체 복사 가능.

p34
[type casting operator == type conversion operator]
	Unary Operator (단항 연산자(피연산자가 한 개))임.
	# Binary Operator (이항 연산자)

[연산자 우선 순위 - 교수님 판서]
==================================
연산에는 우선 순위가 존재한다.

4대 기본 연산자 : 산술, 관계, 논리, 대입 (*산*관없잖아요! *논다는*대!)

int a = 3;
int b = 4;
int c;

c = a%3==0 && b%5!=0;
  = 0==0 && 4!=0;		// 산술연산자가 수행된 결과
  = true && true;		// 관계연산자가 수행된 결과
  = true;			// 논리연산자가 수행된 결과
  = 1;
따라서, c == 1;			// 대입연산자가 수행된 결과

# 모르겠으면 유추해서 길을 찾아가야함.
 유추가 안되면 외워야함 --> 말도 안됨.
 유추하는 방법을 찾아야지! 예를 들 것.	--> 추상적인 개념 발견


그래서, 우선순위를 매기면

특수(어벤져스) : typde(...)  .(헐크)  ->(토르)  [](아이언맨)  ()(캡틴아메리카)
단항(애꾸눈) : (type) sizeof ++ -- *(마법모자) &(마법돌) + -
----------------------------------------------
산술
관계
논리
대입

Value Construction Operator : C++에서 추가된 타입캐스팅 연산자 / type(...) / 우선순위 최상위.
--> C++은 타입캐스팅 연산자가 두 개. 두 개는 기능은 같으나 우선 순위가 다름.

주의
usigned int의 경우 띄어쓰기를 하는 순간 괄호를 해야하는데,
그렇게 되면 더이상 Value Construction Operator가 아니고 타입 캐스팅 연산자임.
Value Construction Operator로 남겨두고 싶다면 typedef을 이용할 것.













