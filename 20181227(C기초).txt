2018.12.27

첫 날 OT.

C++의 기법
1. Encapsulation
2. Inharitance
3. Polymophism

그 이전에 구조적 프로그래밍을 먼저 잘 할 줄 알아야 함.
그러나 또 그 이전에 C언어(특히 pointer)부터 잘 할 줄 알아야 함.
--> pretest 칠 예정. 각각에서 90점이상의 성적을 얻지 못하면 ㅇㅇ..
재시 응시 자격 : 18:00 ~ 21:00 --> (C언어 pointer & 구조적 프로그래밍)특강

겁나 빡신 수업임. 전공자는 목숨걸고 공부해야하는 중요한 과목임.

# 누구나 다 성취할 수 없는 것을 성취하게 되면 특별한 사람이 됨.
  C++은 그런 도전할 가치가 있는 과목임.
==============================================================================================================

02. 기초이론2 - C언어 기본

p3
ALU : 계산을 하기 위한 회로. 데이터(피연산자)를 필요로 함. 이 데이터는 레지스터에 저장.
	정수를 위한 것과 실수를 위한 것으로 두 종류가 있음. --> CPU가 계산 할 수 있는 값의 종류는 정수, 실수 뿐. 
	굳이 하나를 더 추가 하자면 진리값까지 계산이 가능함. 그러나 진리값은 정수로 변환되어서 계산됨.(정수로 인지)
	( 두 가지 : 정수, 실수  /  세 가지 : 정수, 실수, 진리값 )

p4	정수형 ALU에는 정수형 데이터만 들어가고 실수형 ALU에는 실수형 데이터만 들어감.

수학 != 컴퓨터.
수학 (정수가 실수에 포함됨) 	vs	컴퓨터 (정수와 실수는 별개의 수 체계)
4 : 정수이면서 실수			정수
3.0 : 정수이면서 실수			실수
0 : 정수이면서 실수			정수
0.0					실수

계산상의 효율성을 이유로 정수형과 실수형 ALU를 구분 해놓음.

p5
수학적 정의의 변수 : 변할 수 있는 값 	<-->   상수 : 변하지 않는 값
컴퓨터적 정의의 변수 : 값을 저장하는 메모리(Main Memory) 공간	<-->	값 : 의미가 부여된 이진자료  != 메모리
즉, 변수의 본질 == 메모리	(메모리인가? O : 변수 / X : 값)

변수의 타입 == 변수의 종류 (정수형, 실수형)

p6 < C언어의 Pointer를 제대로 해석하기 위한 정의 >
변수 = 주소(L-value) + 값(R-value)	// L : left , R : right
주소 = MM에서 변수의 위치	
값 = 이진자료 + 타입	// 주소를 구성요소로 가지지 않음. --> '주소는 값의 위치다' 라는 말은 틀린 표현임.
이진자료 = 0과 1의 나열
타입 = 값의 표현방식 + 메모리 공간의 크기

p7
MM : Read / Write 두가지 동작만 가능. 엄청난 양의 데이터를 저장가능 --> CPU를 보조함.

p8
메모리 할당 : 비어있는 메모리 공간을 찾아서 위치 시켜줌

# 메모리 할당은 원래 프로그래머가 해야 할 일이지만 OS와 Compiler가 대신 해줌. (비유) OS & Compliler : 김비서
# CPU마다 해석하는 순서가 다름 (Intel은 리틀인디안 방식) --> 시스템 소프트웨어

p9
배열 : *같은 타입의 **연속된 변수들로 구성된 복합 변수
int a[3] : a는 int형 3개로 이루어진 변수. (4bytes * 3 == 12 bytes)
	a의 타입 == int[3]
배열의 길이(length of array) : 구성요소의 개수 --> a의 길이 == 3
배열의 크기(size of array) : 메모리 용량 --> a의 크기 == 12bytes

# index는 0부터 시작
배열의 길이를 벗어나게 되면 Run-time Error 발생.

(비유)
소혜 3형제는 항상 같이 다니고, 나란히 앉는데 자리 순서도 정해져 있음.(배열)
암살자가 소혜 3형제를 제거하라는 의뢰를 받음 --> 소혜만 찾으면 나머지 두 명도 처리 가능.

만약 다 따로 앉아있고 소혜가 둘째의 위치만 알고, 둘째는 셋째의 위치만 아는 상황이라면
암살자는 세 명 모두의 위치를 파악해야함. --> 데이터 처리하기에 어렵고 번거로움.

데이터 처리하기에는 연속된 것이 제일 좋다. --> ***배열은 중요함.
가끔씩은 배열만으로는 처리하기 힘든 데이터들이 있음 --> *트리, 리스트, 그래프 등의 자료구조를 사용.

p11
함수 : 명령의 목록이 저장되어 있는 메모리 공간 	!= 수학적 개념의 함수

# 프로그램 : 명령의 목록(Instruction Sequence)

명령의 목록 즉, 프로그램에는 값(데이터)도 포함됨.
(비유) 갑자기 소혜에게 "덧셈 해봐"라고 하면 못 함. 값도 함께 줘야 함.

# 프로그램은 메인메모리에 저장되어 실행됨. 
프로그램 = 함수(명령) + 변수(값)

함수 : 함수 호출부 + 함수 정의부
함수 정의부 : 일종의 DNA정보일 뿐.
함수 호출 시점 == 함수 동작 시점	// 함수 이름 + 괄호 --> 함수가 태어남. (비유) 사람이 태어나는 시점.
	return문을 수행하게 되면 반환값을 남기고 죽음. 그러나 슬퍼할 필요가 없음. 다시 부르면 살아남. 
(비유) 경진이에게 천원을 주고 음료수를 뽑아오라고 하면 자판기에서 음료수를 뽑아주고 사라짐.

# 호랑이는 죽으면 가죽을 남기고, 사람은 죽으면 이름을 남기는데, 함수는 죽으면 반환값을 남김.

< 교수님 필기 >
함수 시작 : 함수 호출 <-- 함수 이름 + ()
함수 종료 : return문 수행 직후
함수 반환값 : 함수 종료 후, 호출문이 반환값으로 전환
함수 호출시 주의점 : 함수 이름(값)	// Call by Value
			값이 아닌 변수, 수식, 또 다른 함수 호출 --> 값으로 전환될 때까지 호출 보류
				  타입 --> Syntax Error (값이 타입을 포함하는 것이지, 타입 안에는 값이 없음)

(비유) 경진이에게 통장을 주고 자판기에서 음료수를 뽑아오라고 하면 현금으로 바꿔줄 때까지 안 감.
	돌을 주면(보석이 아닌이상 현금으로 바뀔 수 없음) 화 냄. 에러

함수 호출자는 피호출자를 호출 하고나면 정지. 피호출자가 반환값을 남기고 종료되면 다시 활성화.
(비유) 교수님은 경진이를 호출하고 나면 '얼음' 상태임.
	경진이가 음료수를 남기고 사라지기 전까지는 다시 경진이를 호출할 수 없음.

p12
square함수 호출시 변수 x에 저장되어 있던 2.5의 값을 복사해서 square함수에 넣어줌.
Call by Value : 변수가 저장되어 있던 값이 복사됨. 변수가 값이 될 때까지 호출되지 않는다. 
(비유) 경진이에게 천원을 줄 때 쟁반에 담아 줌. 즉, 값을 변수에 담아 줌. 
그리고, 그 변수는 반드시 앞에서 선언되어 있어야 함.

덧셈 연산의 피연산자로 변수가 오면 연산이 불가능. 
그러나 변수가 값으로 전환 될 수 있다면 값으로 전환 되고 나서 연산 가능.
그리고 함수 호출의 결과는 값.

p14
수식 : 연산자와 피연산자의 나열
수식은 반드시 값이 된다. (ex) 1+2 --> 3			// C언어의 절대 원칙
# 가끔씩은 변수가 되기도 함. 연산의 결과로 변수를 가지는 연산자들 4개 있는데 뒤에서 배움.

<연산자>
산술연산자
관계연산자(비교연산자)
논리연산자
대입연산자

p19
컴퓨터가 데이터 통신을 위해서 사용하는 것 : 0과 1	(컴퓨터는 디지털 기기이기 때문)
컴퓨터가 연산(계산)을 위해서 사용하는 것 : 정수, 실수 
# 위의 두 개를 헷갈려 하지 말 것.

정수 표현 방식들.
1) Unsigned
2) sign and Mag
3) 1's Comp
4) 2's Comp
5) Exceed
p25 표를 그릴 수 있어야 함. 최대 최소를 구할 줄도 알아야 함.

# 교수님 말씀이 점점 빨라짐

고정 소수점 : 조금만 더 큰 값을 저장하려고 할 때 저장을 하지 못함 --> 유효숫자를 저장하는데에 있어 비효율적.
부동 소수점(floating point) : 소수점이 유동적으로 왔다갔다 하는 것이 가능 --> 값을 저장하는데에 있어서 효율적.
				--> 표현의 범위가 확대 (유효숫자 확대)
부동 소수점방식을 바탕으로 국제표준화 --> IEEE 754-1985

C언어에서 float : single precision	32bits 중에서 유효비트는 8bits
	  double : double precision 	64bits 중에서 유효비트는 11bits
