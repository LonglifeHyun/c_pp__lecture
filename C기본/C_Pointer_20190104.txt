C_Pointer_2019.01.04

C언어 포인터 part1

p44
[배열]

X[N] a;		// 개념적 타입
X a[N];		// C언어 타입

# 개념적 타입은 실제로 사용하게 되면 구문오류(SE)를 발생시키지만 포인터를 이해하기 위해서는 잘 알아두는 것이 좋다

< 개념적 타입 --> C언어 타입 규칙 >
1) []는 뒤에 있는 것부터 변수 뒤로 넘긴다.
2) []뒤에 *이 있을 경우
	[]뒤에 있는 모든 내용을 ()로 묶은 후 []를 뒤로 넘긴다.
3) []뒤에 *이 없을 경우
	그냥 []를 뒤로 넘긴다.

// 개념적 타입 --> C언어 타입
int[2][3]**[4]*[5]	a;	// 개념적 타입
int[2][3]**[4]*      a[5];
int[2][3]**    (*a[5])[4];
int[2]  (**(*a[5])[4])[3];
int  (**(*a[5])[4])[3][2];	// C언어 타입

< 개념적 타입 --> C언어 타입 규칙 >
1) []는 뒤에 있는 것부터 변수 앞으로 넘긴다.
2) []앞에 )이 있을 경우
	[]를 앞으로 넘긴 후 []뒤에 있던 ()를 제거한다.
3) []앞에 )이 없을 경우
	그냥 []를 앞으로 넘긴다.


// C언어 타입 --> 개념적 타입 
int  (**(*a[5])[4])[3][2];	// C언어 타입
int[2]  (**(*a[5])[4])[3];
int[2][3]**    (*a[5])[4];
int[2][3]**[4]*      a[5];
int[2][3]**[4]*[5]      a;	// 개념적 타입

# 공백은 자유롭게 넣어도 무관

p45
배열의 요소타입을 구하는 방식 --> 외울 것

ET( X[N] ) == X		// 제일 마지막 []을 제거

< 배열의 길이 vs 배열의 크기 >
배열의 길이 : 배열의 구성요소의 개수
배열의 크기 : 배열의 메모리 용량

the length of array : the number of elements of array
the size of array : the size of memory

T(a) == double[3]

p = &a[0];	// p는 a[0]의 주소값을 저장함으로써 a[0]를 가리킨다.

a는 배열, p는 포인터로 둘은 다른 것이다. --> size가 다름

p46
배열의 길이 = 배열의 크기 / 구성요소의 타입	// 외울 것

p47
배열의 묵시적 타입 변환 --> Pointer 를 이해하기위해 제일 먼저 알아두어야 할 개념
# 배열의 묵시적 타입 변환 은 교수님께서 만드신 개념이 아님. 

# < assignment 연산자 문법 규칙 >
   1) 왼쪽 변수,오른쪽 값
   2) 타입일치
   3) 결과값은 대입값

# 4대 기본 연산자의 피연산자로 올 수 있는 값의 종류 : 정수 실수 진리값 --> ALU가 연산. register에 들어갈 수 있는 유일한 것들.
  배열과 구조체의 경우 크기에 매우 다양 --> register에 들어갈 수 없다.

# 모든 것은 컴퓨터 구조와 연관이 있음. 구조의 이해 없이는 C언어를 완전히 이해하기엔 무리

T(p) == double*
T(&a[0]) == double*
T(a) == double[3]

p = a;		// SE (1) assignment 문법 규칙에 위배 (2) assignment 피연산자로 배열타입이 온 것도 문제 
--> *오류가 있으므로 &a[0]로 변환됨 (double[3] --> double*)

배열의 묵시적 타입변환은 오류가 있을 때에만 발생.

배열의 묵시적 타입 변환의 결과 : 복합값 --> 단일 주소값(첫번째 요소의 주소값)


p48
f(a);	//함수인자로는 값이 되어야 하는데 배열을 사용 --> SE 인데 배열의 묵시적 타입 변환

p49
double a[3];
p = &a[0];

p+0 == &a[0] == 48번지라고 가정

p+1 != 49번지
p+1 == 56번지

이유? (비유)
교수님, 민규, 다윗이 세로로 쭉 누워있음. 교수님 구간만 보면 교수님. 민규 구간만 보면 민규.
그러나 교수님 허리부터 민규 허리까지 잘라서 그구간만 보면 더이상 교수님도 민규도 아님. -> 의미 없는 것이 됨

마찬가지로 p+1이 의미있는 주소값이 되기 위해서는 진짜 1만을 증가시키는 것이 아니라 타입의 크기만큼 증가시켜야 함.
단순히 1만을 증가 시킨 결과인 49번지는 쓰레기값임.

따라서, p+1 == 48 + 8 == 56번지

==> p + i == p + sizeof(RT(p)) * i	// 생략된 것이 보여야 함. 
# RT는 T에 *을 제거 (외우고 있어야 함)
		
포인터의 곱셈과 나눗셈은 존재하지 않음 <-- 의미가 없음
--> SE 발생하도록 만들어 놓음

(비유)
교수님 집이 장전동 100번지. +10은 교수님 옆집, *10은 장전동 1000번지로 누가 살수도 있지만 교수님과는 무관.

* 소스코드를 보고 메모리 구조를 그려낼 수 있어야 함.

*p50
왼쪽 코드와 오른쪽 코드는 동일한 결과를 출력 --> 거의 외우다시피 할 것.

p51
# 생략된 sizeof(RT(p))가 보여야 함

컴퓨터도 우리와 같은 방식으로 연산함. 우리는 12+24를 12*24보다 빨리 계산함.
--> 컴퓨터는 덧셈을 곱셈보다 수십배 정도 빨리 연산함.

그래서 속도가 중요했던 과거에는 속도가 비교적 느린 덧셈 연산(곱셈연산이 생략)을 사용하는 것은 비바람직한 일이었다.
그래서 증감 연산(덧셈연산만을 사용)을 사용했다.
그러나 요즘은 널린게 CPU이고 워낙에 빨라서 속도 차이를 실감하지 못할 정도임.
그래서 어느 것을 쓰든 중요치 않은 문제임

# 후치 ++은 해석하기 힘드니 뒤에 증가 시키는 것으로 분리 시킬 것

p52
a[3]는 존재하지는 않지만 계산상으로 계산은 할 수 있음.
실존하지 않는 것을 가리키는 것까지는 문제가 되지 않음. 그러나, *을 함부로 씌우면 안됨. 

(비유)
민규가 교수님의 집주소를 저장하고있음.
교수님이 돌아가심. 모두가 그 사실을 알고 있음.
민규가 다윗을 만났을때 *마법모자를 쓰면 교수님이 됨. 
다윗이는 유령이 나타났다고 생각하고 도망감 --> Run-time Error

* dangling pointer : 잘못된 주소값을 가지고 있는 포인터
 dangling pointer 그 자체로는 문제가 되지 않지만 여기에 *을 씌우게 되면 RE

*p53
# 왼쪽의 코드를 보고 for문으로 바꾸고 싶다는 충동이 안들면 프로그래머가 아님
	(비유) 김고은을 보고도 그냥 지나치면 남자가 아님

p54
모두 p53의 오른쪽 코드와 같은 것임.

for(p=&a[0]; p<&a[0]+s; ++p) 
for(p=a; p<a+s; ++p)
for(p=a; p<&a[s]; ++p)

for(p=&a[1]-1; p!=&a[0]+s; ++p)
... 많다
--------------------------------------------
double a[3];
double* p = &a[0];
double* q;

&a[0] == 1000
&a[1] == 1008
&a[2] == 1016

q = p + 2;

if(q == p + 2)	// ok
if(q - p == 2)	// ok? --> ok!

# 생략된 sizeof(RT(p))가 보여야 함

if(q == p + 2*8)	
if((q - p)/8 == 2)	
----------------------------------------------
int* + int 	// ok 	p(int*) + 0(int)
int* - int	// ok
int* * int	// SE (의미 없음)
int* / int 	// SE (의미 없음)

double* + double* 	// SE (의미 없음)
double* - double*	// ok (위에 q - p) 결과의 타입은 int, 의미: sizeof(RT(p)) * N
double* * double* 	// SE (의미 없음)
double* / double* 	// SE (의미 없음)

p56
[배열 연산자]

# 짚고 넘어가야 할 것 (*의 구분 <-- 사용처를 보고 구별할 것)
int* p = &a;	// * : 타입을 위한 것
*p = 99;	// * : 별표마법모자
3*2;		// * : 곱셈 연산자

< 연산의 결과로 값이 아닌 변수를 갖는 연산자 4개 >
 1) *(별표 마법 모자)
 2) . (헐크)
 3) -> (토르)
 4) [] (아이언맨)
 --> C언어에서는 이 네개가 다 임.

*(p).id 이게 불편해서 Dennis Ritchie가 p->id로 쓸 수 있게 요소참조연산자 ->를 만듦.
마찬가지로,
*(p + i) 가 불편해서 Dennis Ritchie p[i]로 쓸 수 있게 배열연산자 []를 만듦. 
따라서, p[i] == *(p + i) 는 정의

p57
[포인터 배열]
T(a) == int*[3]		// pointer를 3개 가지고 있음. --> 본질은 배열.

p58
a의 타입(ET)을 찾아가는 방법

*a[0] == x	: 	a[0] --> x	:	a[0] = &x
*a[1] == x	: 	a[1] --> y	:	a[1] = &y
*a[2] == x	: 	a[2] --> z	:	a[2] = &z

ET a[3] = {&x, &y, &z};
int* a[3] = {&x, &y, &z};

[C언어에서 변수의 종류(classification)]
 1) 기본타입 : int, double, char ...
 2) 배열
 3) 구조체
 4) 포인터
 ex) 선언		변수의 종류	타입
     double* p;		포인터		double*
     struct stud s;	구조체		struct stud
     double a[3];	배열		double[3]

[배열 포인터]
 배열을 가리키는 포인터

 이 뒤로는 쭉쭉 이해하면서 넘어가자

p61
[배열 요소 포인터]
  배열의 구성요소를 가리키는 포인터
  교수님 " 앞에서 다 한 거잖아. 당연한 거야! 난 설명을 너무 잘해."
# p[i] == *(p + i) 는 정의

p62
배열 요소 포인터는 배열의 구성요소를 가리키는 포인터! 말을 잘 해석해보면 답이 나옴
-->배열 요소 포인터는 포인터임에도 배열처럼 요소 참조가 가능.
	(배열 포인터가 아니라, 배열 요소 포인터일 때,  가능)

# 이거 이해하는게 교수님 포인터 강의 핵심.

p63
 타이핑하기에 배열 포인터가 배열 요소 포인터에 비해 번거로움. 배열 요소 포인터가 더 편리.

p64
왼쪽엔 오류가 없음. & + 변수 --> ok
오른쪽엔 오류. 배열을 넣으면 안됨 -->  묵시적 타입 변환에 의해 &a[0]로 변환됨.


p65
double* p; 
--> 이것만 보고는 double 포인터인지, 요소 포인터인지 알 수 없음
    뒤의 내용을 봐야함.

p68
[문자열 상수]
문자열(string)
	char 배열, 변경 가능
문자열 상수(string constant)
	char 배열, 변경 불가능
--> 둘 다 변수(배열이기 때문) 즉, 메모리공간

printf("%s\n", "abc");
"abc" 의 종류 : 배열
"abc" 의 타입 : char[4]

char* p = "abc"; 	//  p의 종류 : 포인터, T(p) == char*
--> 배열을 포인터에 assignment하는것은 불가. 
--> 묵시적 타입변환에 의해 p는 첫번째 요소 즉, 값 a가 저장되어 있는 주소를 가리킴.

p[0] == *(p+0) == *p

initializer : 배열을 초기화 해주는 것.
char a[] = "abc"; // "abc" : initializer

int a[] = {11,22,33};	// ok. 사실은 SE인데 compiler가 [3]으로 알아서 변환해줌.
int a[];		// SE

char a[4] = {97,98,99,0};
char타입의 정의 : 1byte 정수형. 문자타입이 아님. 컴퓨터는 정수, 실수, 진리값 밖에 처리하지 못하기 때문.
--> 정수를 저장해서 문자코드를 사용. 문자를 저장하는 것이 아님. 문자를 저장하기 위한 정수값.
    계산을 위해서 만든 타입이 아니라, 효율적인 저장을 위해서 만든 타입

# 실수의 계산을 위해서 만든 기본 타입은 double(32bits 컴퓨터_80년대 후반 등장)
	16bits 시절에는 float였음

char a[4] = {97,98,99,0}; 	// original
char a[4] = {'a','b','c','\0'};	// 위와 같은 것. 이 방법이 가독성을 더 높이는 방법. 단, 타이핑의 단점이 있음.
char a[4] = "abc";		// 위와 같은 것. 타이핑에 유리.

위의 세 개는 진짜 완전히 아주 그냥 똑같음.
따라서, {97,98,99,0}, {'a','b','c','\0'}, "abc" 이거 셋 다 initializer임.

char a[] = "abc";	// initializer
char* p = "abc";	// 문자열 상수

initializer이기 위해서는 선언문이어야 함. + char타입의 배열이어야 함.
즉, 문장에서는 모조리 다 문자열 상수.

p = "efg" // 묵시적 타입 변환. p에 첫.요.주. 저장됨
a = "efg" // assignment 피연산자로는 배열이 올 수 없음. 그래서 a도 &a[0]로 변환이 일어남
	--> 컴파일하게 되면 L-value가 쓰여야 하는데 R-value가 왔다 라는 에러메시지를 보여줌.

p69
구조체 복사 X --> 최신에선 바뀌긴 했..

p70
 b도 타입변환이 일어나서 error

p71
 구조체 대소비교 불가

p72
 배열의 대소비교 불가 --> 묵시적 타입변환에 의해 각각의 첫.요.주.를 비교하게 됨.
 그러나, 의미가 없음. 논리 오류임.

+) 다음과 같을 땐 가능
int a[3] = {11,22,33};
int* p = &a[2];
while( p >= a ){	// p >= &a[0]
	--p;
}

p73
[함수]
구조체 안의 값을 
Call by Address를 쓸 수 밖에 없음.
그러나 잘 안쓰는 것이 좋음 --> 호출함수만을 보고는 이해가 불가능 --> 유지보수에 비효율적.

웬만하면 가능하면 Call by Address보다는 Call by Value를 쓰도록 해야함.

(비유)
혜교와 중기가 집에 간다. 
큰 길로 갈 때는 혜교의 립스틱 색은 바뀌지 않음.
어두운 샛 길로 갈 때는 립스틱 색은 바뀌었을 수도 있고, 아닐 수도 있다.
그러나 기대치라는 것이 있음. 
립스틱 색이 변하지 않았으면 혜교는 중기에게 헤어지자고 함.

웬만하면 샛 길로 가지 말라고 했는데 굳이 갔다? 
기대하게 만드는 것임. 근데 립스틱 색이 바뀌지 않았다? 

마찬가지로, 코딩에서도 Call by Address를 웬만하면 쓰지 않는것이 원칙인데, 썼다면 바꿀 것이라는 뜻임.
그래놓고 안바꿨다? 눈치없는 프로그래머임.

그런데 구조체에서는 샛길(Call by Address)밖에 없음. 립스틱 색이 바뀔 확률은 반반.

그러나 최신에서는 큰 길(Call by Value) 방법이 생김. 그럼 립스틱 색이 바뀔 확률이 올라가지 않을까?
그런데, 큰 길이 매우 위험하고 불편한 길임. 그 길로 가는 건 비효율적. 여전히 확률은 반반

--> 샛 길을 이용하자. pointer를 이용

p74
#include <stdio.h>

//void print(int p[3])
//void print(int p[])
void print(int* p)	// Original
{
	int i;
	for(i=0;i<3;++i)
		printf("%d\n",p[i]);
} 
 
int main(void)
{
	int a[3] = {11,22,33};
	print(a);
	return 0;	
}
--------------------------------------------
1) void print(int p[3])
2) void print(int p[])
3) void print(int* p)	// Original

이 셋은 같은 말. 그러나 3)이 진짜임. 1) 2)는 잘 모르는 상태에서 좀 더 쉽게 배우기 위해 만든 것일뿐.
(비유) 준희는 아빠의 친아들로 알고 있었는데, 나아아중에 결혼식 전날 입양 된 아들임을 알게 됨.  

p75
1) 2)의 코드는 모두 3)으로 바뀌어서 컴파일 됨.
증거 : f1, f2, f3 모두 포인터의 크기가(4bytes) 출력.

그런데, 큰일 남.

p76
함수에서 배열의 길이를 전달할 수가 없음.
< 해결책 >
1) 외부 변수 
	장점 : 2) ~ 3) 의 단점을 모두 보완 가능.
	단점 : 사장님이 싫어해서 사표써야함. 함수간의 공유로 인해 유지보수가 힘듦. 거의 쓰이지 않음.
2) 매크로(상수값을 사용 _ #define SIZE 3)
	장점 : 한가지 길이(길이 고정)의 배열에서는 최적.
	단점 : 길이가 고정된 배열에서만 사용가능. 다양한 길이의 배열 사용 불가. 
3) 인자(함수 인자로 전달)
	주의) int a[3]으로 보이면 안되고, int* a 로 보여야함
	장점 : 서로 다른 길이의 배열에 적용 가능. 가장 많이 사용되는 방법.
	단점 : 전달하는 인자의 개수가 늘어나게 되면 프로그램이 복잡하고 지저분해 보임.
4) 특정 값(terminal signal로 사용)
	장점 : 다양한 길이 ok, 인자 개수 늘어나지 않음
	단점 : 특정 값 자체를 데이터로 활용할 수가 없음 --> 잘 정해야 함

==> 네 가지 모두 장단점이 다 있음. 반드시 잘 이해하고 있다가, 상황에 따라 적절하게 활용해야함.























