C_구조적 프로그래밍 2019.01.10

구조적 프로그래밍 2편.

[주석문]
프로그래밍에서 매우 중요. 있어도 되고 없어도 되고 이런게 아님. 
복잡한 프로그램을 잘 기술하는 것은 중요함.

< 주석문의 역할 >
1) 설명
2) 코드 비활성화 / 활성화
multi-line
single-line

[개행문(new line)]
'\n'

[표준입출력_정수 및 실수 출력]
double a = 3.14;
printf("%f\n",a);
printf("%lf\n",a); 

--> 둘 다 써도 됨. 

이유.
16bits 컴퓨터 시대에 
float는 %f, double 은 %lf를 사용
2바이트 전송이 이루어지던 시대에 4바이트인 double의 전송은 부담스러웠음.
그래서 float가 주였고 double은 잘 사용하지 않았음

32bits 컴퓨터로 넘어오면서
더이상 4바이트 머신에서 8바이트 전송은 부담스러운 것이 아님. 

가변인자 전송을 할 때 데이터 전송의 효율성을 위해서
char, short, int 등 정수 타입은 무존건 4 바이트.(단, long long은 8바이트)
실수는 무조건 8 bytes로 통일.

그래서 float --> double로 4바이트 --> 8바이트로 확대되어서 전송됨. : packing
printf의 입장에서는 float나 double이나 둘 다 double로 느껴짐.
// C89 : 제대로 문법 체계가 갖춰진 표준임.

(정리)
float f;
scanf("%f", &f);
printf("%f", f);

double d;
scanf("%lf", &d);
printf("%f", d);	// 이게 원래 표준. 근데 표준 이전의 프로그래머들이 %lf를 쓰니까 이것도 인정은 해줌.

# 메모리 낭비를 하더라도 데이터 전송과 메모리 참조에 효율을 위해서 구조체 패킹(Packing)을 사용.

scanf쓸때에도 "%d" 딱 요렇게! 공백은 하나도 넣지 않는 것이 정석. 그러나 공백을 넣어도 됨. 
이유.
scanf의 FSF(%d, %f, %lf, %s)는 skip space를 내재하고 있음.
주의) %c는 skip space를 내재하고 있지않음. 이런 내재하고 있지 않은 FSF를 위해서 공백을 만들어둠.
그니까 공백도 그냥 만들어둔 것이 아님. 남용하지 말 것. 

p16
두개를 입력받도록 코딩해놓고 실행시에 하나의 데이터만 주고 엔터하면 결과를 보이지 않고 계속 입력받으려 깜빡임
한꺼번에 두개의 데이터 다 주고 엔터하면 바로 

[산술연산자의 활용]
< 나머지 구하기 >
#include <stdio.h>

int main(void)
{
	int stud, apple;
	int remain;
	
	scanf("%d%d", &apple, &stud);
	remain = apple%stud;
	printf("remain == %d\n", remain);
	return 0;
}

< 수열의 합 구하기 >
#include <stdio.h>

int main(void)
{
	int a, d;
	int sum;
	
//	l = a+ (n-1)d
	scanf("%d%d", &a, &d);
	sum = (2*a + 9*d) * 10 / 2;
	printf("sum == %d\n", sum);
	return 0;
}

< 원뿔의 부피 구하기 >
#include <stdio.h>

int main(void)
{
	double r, h, pi =3.14;
	double volume;
	
	scanf("%lf%lf", &r, &h);
	volume = 1.0 / 3.0 * pi * r*r * h;
	printf("volume == %f\n", volume);
	return 0;
}

주의) 혼합연산 금지. double 타입으로 다 통일해서 계산.

p20
[오류]
원래는 다음의 두 개로만 분류되는 것이 이론.
compile 할 때의 error.
Run-time 할 때의 error.

그러나 관습적으로는 세개로 분류.
구문, 논리, 실행

< 중첩 주석 오류 >
multi-line일때만 발생.
구문오류

< 세미콜론 없는 문장/선언 >
구문오류

< 선언되지 않은 식별자 >
구문오류

< scanf 함수 & 미사용 >
실행오류 (발생확률 99%의 실행 오류) <-- 쓰레기 값을 쓰레기 주소로 저장하기 때문.

< scanf 함수 입력 트러블 >
논리 오류 _ scanf에 new line나 공백이 들어가면 안됨.
#include <stdio.h>

int main(void)
{
	int a;
	
	scanf("%d\n", &a);		// new line(\n)은 들어가면 안됨
	printf("a = %d\n", a);
	return 0;
}
--> 입력을 두 번 해야 결과가 나옴. 

< scanf 함수 잘못된 FSF >
논리 오류 _ double타입을 입력 받을 때에는 %lf를 사용해야함

#include <stdio.h>

int main(void)
{
	double a, b;
	
	scanf("%f%f", &a, &b);
	printf("sum = %d\n", a+b); 
	return 0;
}

"%f"로 입력을 받게되면 double타입이 아닌 float타입으로 인지. 
--> 8바이트가 아닌 4바이트에 저장. 유효숫자가 맞지 않게되어서 쓰레기 값이 출력됨.
메모리 영역 자체는 침범하지 않으므로 실행오류가 발생하지는 않음.

역은? (float영역에 double타입을 넣으면?) 
4바이트 공간에 8바이트가 들어가므로 4바이트를 더 초과되어서 메모리를 사용
실행오류가 발생할 확률은? 매우 낮음. 발견할 확률도 낮으므로 매우 위험한 코드임.
초과한 4바이트 메모리도 프로그램에 할당된 메모리 영역일 가능성이 높음. 주로 논리 오류가 발생.

# 위와 같은 내용을 이제는 포인터를 알기 때문에 파악할 수 있어야 함.

< 혼합연산 >
논리 오류
실수를 사용해야하는데 정수를 사용. --> 묵시적 타입변환
+) 연산 순서도 영향을 끼침. 

# 묵시적 타입 변환의 내막을 완벽하게 알 수 있다면 써도 되는데 그냥 혼합연산 자체를 쓰지 말도록 하자.
항상 명시적으로 사용할 것.

< 0으로 나누기 >
실행 오류

< 나머지 연산자의 오류 >
구문 오류 _ 실수 타입에 대해서 나머지 연산자를 사용할 수 없음


===================================================================================================================
구조적 프로그래밍 3편.

[if문 활용]
선택적 실행 --> if문

짝수 조건
1) a%2==0
2) a%2!=1
3) !(a%2==1)
4) !(a%2!=0)

p10
else를 if로 바꾸려면 else와 연결된 if의 반대조건을 넣으면 됨.
실행문을 바꿀 때에도 마찬가지 (p11)

복합조건의 단일 if문을 중첩 if문으로 바꿀 때에는 복합조건에서의 앞 조건부터 if문으로 만들어줘야함.
반드시 순서를 지킬 것.

p15 (중요)

# false || A == A	// false || 는 생략할 수 있다 / 넣어도 된다.
  True && A == A	// treu && 는 생략할 수 있다 / 넣어도 된다.

* 중첩 if문을 if-else문으로 바꾸기 위해서는 *공통조건을 조건문으로 넣으면 됨.
	헷갈리지 말 것.
#include <stdio.h>

int main(void)
{
	int a, b;
	
	scanf("%d%d", &a, &b);
	
	if(a==1 && b==1)
		printf("a==1, b==1\n");
	else if(a==1)
		printf("a==1, b!=1\n");
	return 0;
}

필기대비 연습문제
12입력의 결과로 보아서 3의 배수이면서 동시에 2의 배수는 아니라는 조건이어야 함.
--> 공통조건인 3의 배수이다. 라는 조건이 들어가야함. 

이런 문제는 딱보고 10초안에 풀어야함. 기본이기에 스피드가 중요함.

[배타적 조건] 
용어 자체를 이해하도록.  --> 실전 코딩

배타적 조건 --> 배타적 실행 (역은 반드시 성립하는 것은 아님)
조건 두개가 배타적 실행을 따른다면 순서를 바꾸어도 무관.
주의) 배타적 조건이 아닌경우네는 순서를 바꾸면 안됨.

p21
else가 아니면 배타적 조건이 아니므로 함부로 없애면 안됨. --> 동시실행이 가능. 논리 오류 발생

연속 if문 vs 개별 if문

배타적 실행 vs 동시 실행
	배타적 실행 : 연속, 개별 if문 둘 다 사용가능.
	동시 실행 : 개별 if문만 사용가능

실행순서가 중요한 상황인지 아닌지를 판단해서 상황에 따라 if문의 순서를 바꿀 수도 있다.
if문의 전환이 중요한 이유.
구조적프로그래밍 refactoring(simplification)에 유리. (일단 짜놓고 간단하게 만들어놓는 것) --> 유지보수에 유리. 

연속 if문 --> 개별 if문 : 항상 가능 (역은 항상 성립하는 것이 아님)
이렇게 만들어진 개별 if문은 배타적 조건이 됨. --> 순서를 바꾸어도 무관

배타적 실행을 하는 연속 if문에 대해서는 그 순서를 바꾸면 안됨. (p29)
개별 if문에 대해서는 가능.

위치 순서를 바꾸려면
연속 if문을 개별 if문으로 바꾼뒤에 수행해야함.

[for문]
요령 --> speed --> good at programming

p42 어떻게든 할 줄 알아야 함. 단, 빠르게.
for(i=0;i<100;i=i+1)		// 기준!
--> i=0*n+m, i<100*n+m, i=i+n
for(i=m;i<100*n+m;i=i+n)






















