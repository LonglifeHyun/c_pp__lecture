C_Pointer_2019.01.03

[C언어 목차]
1) 이론
2) C언어 기본
3) Pointer part1 (초급)
4) Pointer part2 (고급)
5) Pointer part3 (개념적 타입)
6) 구조적 프로그래밍1
7) 구조적 프로그래밍2

C언어 포인터 Part1

[포인터]

변수 = 주소값(L-value) + 저장값(R-value)

p8
포인터 : 주소값을 저장하는 변수(메모리 공간)
	변수이기 때문에 사용하기전에 반드시 선언 되어있어야 한다.

int a;
int* pa;	// pa가 가리키는 대상의 타입 즉, reference type == int 
pa = &a;	// pa는 a의 주소를 저장함으로써 a를 가리킨다.

p9
선언시 공백의 위치는 중요치 않다.

int a[3], b;	// T(a) == int[3], T(b) == int
int a[3], b[3];	// T(a) == int[3], T(b) == int[3]

마찬가지로, 
int *c, d;	// T(a) == int*, T(b) == int
int *c, *b;	// T(a) == int*, T(b) == int*

p10
T(pa) == int*
RT(pa) == int 	// RT은 주어진 T에서 *을 제거
PT(pa) == int**

T(a) == int
PT(a) == int* 	// PT는 주어진 T에서 *을 추가
RT(a) == None

[포인터 연산자] 
 주소 참조 연산자 (reference operator) &
 변수 참조 연산자 (dereference operator) *

&의 피연산자는 변수가 와야하는데 값이 오게되면 SE
*의 결과는 변수

수식은 값이 되는 것이 원칙이나, 결과로 변수를 가지는 예외가 있다. 
--> *연산자

[교수님 판서]
 Pointer : a Variable in which a address of a variable is stored.

 reference operator : & + variable --> address
 dereference operator : * + address --> variable

 int a;
 int* p = &a; 	// p는 a의 주소값을 저장함으로써 p를 가리킨다.

 RT(X*) == X
 PT(X) == X*

 T(&a) == PT(a)
 T(*p) == RT(p)

# 반드시 빠르게 나올 수 있도록 이해를 바탕으로한 암기 필수! 
  소스코드를 보고 메모리 구조를 그릴 수 있게 할 것.
-----------------------------------------------------------------------------
[구조체]  
p13
# 배열 : *같은 타입의 *연속된 변수들로 구성된 복합변수
구조체 : *다른 타입의 *연속된 변수들로 구성된 복합변수

int a[3]; --> 메모리 구조가 그려짐

struct aaa s; --> 메모리 구조가 그려지지 않음. 그냥 구조체 변수 선언일 뿐.
*구조체는 구조체 변수 선언 전에 구조체 타입을 선언해주어야 한다.

struct aaa{		// 구조체 타입 선언. T(s) == struct aaa
	char	a;
	int	b;
	double	c;
};

구성요소 참조 시 배열은 [] 사용, 구조체는 . 사용
ex) a[0] / s.c

구조체 타입 선언
	struct라는 키워드가 있어야 함.
	마지막에 ;이 있어야함. 타입 선언도 하나의 문장이므로.
	메모리 할당은 변수 선언 시에 일어나므로 메모리 할당이 되지 않음
구조체 변수 선언
	struct라는 키워드가 있어야 함.
	--> C++에서는 필요없음
요소 참조 연산자(.)
	사용법 : 구조체변수.요소 == 변수
	연산의 결과가 *변수가 되는 예외 4개 중 하나. 
구조체 초기화
	원소의 타입과 값의 타입이 일치해야함

[요소 참조 연산자(->)]
	struct stud s;
	struct stud* p = &s;	// p는 구조체 s의 주소를 저장함으로써 s를 가리킨다.
	
	*p.id == 11;	//error. 연산자 .의 우선순위가 연산자* 보다 높기 때문
			.을 먼저 연산하게되면 .의 왼쪽 피연산자는 구조체가 와야하는데 구조체 포인터가 옴 --> SE
	(*p).id == 11;	// ok 그러나, 써야할 기호가 많아서 번거로움.
	p->id == 11;	// 위와 같은 표현(정의). 위의 단점을 보완

	사용법 : 구조체주소->요소 == 요소
	연산자 -> 도 연산결과로 변수를 가지는 특별한 연산자임.

# 연산 결과로 변수를 가지는 특별한 연산자 4개 : *(애꾸눈) .(헐크) ->(토르) 

# 연산 우선순위
영웅 : .(헐크), ->, [](아이언맨), ()(캡틴 아메리카)
애꾸눈(단항) : ++  --  *  &
산술
관계
논리
대입

[교수님 판서]

struct { int id; char name; double grade; } s;	// 13(4+1+8)bytes의 구조체 타입

--> 복잡하므로 다음과 같이 나타냄
struct { 
	int id; 
	char name; 
	double grade; 
} s;
----------------------------------------------------------------------------------
struct { int id; char name; double grade; } s, q;
....
struct { int id; char name; double grade; } r; 	// 구조체 이름이 없어서 반복해야함 --> 번거롭다.

--> 번거로움을 해소시키기 위해 구조체 이름을 붙여주면 됨.

struct stud{ int id; char name; double grade; } s, q;
...
struct stud r;
--------------------------------------------------------------------------------------
*이렇게도 가능 --> 제일 많이 쓰는 방법임.

struct stud{ int id; char name; double grade; };

struct s, q;
struct r;

[문자열 상수]
 (문자코드와 문자열에 관한 내용은 C언어 기본 강의 보고 공부 할 것.)

 문자열(string) : char 타입의 배열, 변경 가능
 문자열 상수(string constant) : char 타입의 배열, 변경 불가
 T("abc") == char[4]	// '\0'이 생략 되어 있음
 * 문자열 상수는 변수이다. 즉, 메모리 공간. 배열은 변수이고, 문자열 상수는 배열이므로.
 
 ""로 묶여 있으면 문자열 상수 --> printf("%s\n")에서 "%s\n"도 문자열 상수 (타입은 char[4])

p24
 문자열 상수들 사이에 공백이 있으면 지우고 컴파일.
 --> "Hello,"  " World\n"는 두 개의 문자열처럼 보이지만 사실은 하나의 문자열임.
 문자열 상수를 여러줄에 걸쳐서 쓸 때 함부로 공백을 넣으면 안됨.
 인덴트를 넣으면 인덴트만큼의 공백도 문자열에 포함되어버림.

 이렇게 문자열 상수를 분리할 수 있게 한 이유는?
	문자열 상수가 너무 길어지게 되면 가독성이 떨어짐.

p25 
[C언어의 변수 타입]
int : 계산을 위해서 만들어진 타입으로 유일함.
char, short : 저장만을 위해서 만들어진 타입.

# 16bits 컴퓨터 시대에 C언어가 시작. 이때의 int의 크기는 16bit(2bytes)
--> 32bits 컴퓨터 시대가 열리면서 int의 크기는 4bytes로 증가
--> 기존의 int를 short가 대체
--> long 타입이 4bytes인 시스템도 존재하고, 8bytes인 시스템도 존재하게됨 (단, 교수님 기준은 4bytes) 

!) 각 타입의 Size만 외우고 Min/Max Value는 외우는 것이 아님.
	Size만 알면 앞의 내용으로부터 다 나옴

Pointer의 Size == Word Size

Word Size : CPU의 범용 Register의 크기

16bits 컴퓨터의 WordSize == 16bits
32bits 컴퓨터의 WordSize == 32bits	---> 배우는 기준
64bits 컴퓨터의 WordSize == 64bits

# long double 타입은 표준이 아님. --> 시스템에 따라 다름. : 그냥 이런 타입이 존재함을 알고있고, 무시해도 무방

[명시적 타입 변환] & [묵시적 타입 변환] : 인강으로 대체

p33

[함수]
함수 호출의 결과는 반드시 값이 된다. 값이 되지 않았다면 값이 될 때까지 기다림

circle함수에서 square함수를 호출했다가 6.25를 반환하고 나면, 
circle함수에서의 square함수는 6.25라는 값으면 변환됨.

+) 함수 호출 구조에 관한 것도 인강으로 대체

p34
main 함수가 호출되기 전 전역변수가 먼저 생성이 됨.

함수 호출 순서
main -> circle -> square -> circle -> main -> cone -> main

p35
[전역변수의 활용]
1) 이전 작업 정보의 기억
	전역변수 s에 n의 값을 누적.
	마지막에 sum(0)를 하는 이유? 
	현재까지의 누적된 값을 확인하기 위함.
	이 때, 전역변수 s를 지역변수로 만들면 이 작업은 불가능. --> Logical Error
	(비유) 교수님이 죽고나서 환생할 수 있다고 가정.
		죽고나면 몸은 흙으로 사라짐. 저장되어있던 모든 정보가 사라짐. 새로 태어나면 다시 리셋.
		교수님의 수명이 100년인데 해야할 일은 300년이 걸림.
		이전의 기억이 계속 유지가 되어야 할 수 있는 일임. 뇌는 죽고나면 사라지기 때문에 저장불가능.
		금정산 산꼭대기 바위에 할일을 각인시킴. 새로 태어나면 읽고 할 일을 마저 수행 가능.
		여기서 뇌는 지역변수, 바위는 전역변수.
2) 함수간의 정보 공유
	sum()함수, print_sum()함수 모두 전역변수 s를 참조함.
	내가 할일을 하다가 죽으면 자식(또 다른 함수)이 할 일을 대신함.
	
	*주의) 장점이지만 큰 단점이 되기 때문에 사용이 바람직하지 못함.
	나만 쓰려고 만든 전역변수인데 다른사람이 함수에 사용했다면 Syntax 혹은 Logical error발생.
	문제점을 찾고 수정하는데 시간과 비용이 듦. --> 유지보수에 불리

그러나, 전역변수의 역할인 이전 작업 정보의 기억이 필요할 때가 있음
-->
[정적(static) 지역 변수] 
	사실은 전역변수인데 지역변수로 위장.
	프로그램의 시작 및 종료시에 생성 및 파괴가 됨. 
	쉽게 함수 외부로 빼내서 해석하도록 할 것.
	참조 범위가 선언된 위치에서 함수까지만이기 때문에 다른 함수에서 사용이 불가함.

p38
[값의 전달]
p41 Call by Value 
	main함수의 지역변수의 값은 return값을 가진 assignment의 연산을 통해서만 바뀔 수 있다.
p42 Call by Address
	main함수(Caller함수)의 지역변수의 값이 함수 호출 결과 바뀜.
(비유)
Call by Value : 냉장고를 공유하지 않는 연인관계(메모리를 공유하지 않음)
	경진이가 사과를 두개 사서 여자친구에게 하나 선물함. 여자친구가 집에가서 밤에 하나 사과를 먹음.
	그래도 경진이의 냉장고에는 사과가 두개 그대로 있음. 다른 냉장고이기 때문.
Call by Address : 냉장고를 공유하는 부부관계(메모리를 공유)
	경진이가 사과를 두개 사서 아내에게 하나 선물함. 아내가 집에가서 밤에 하나 사과를 먹음.
	그럼 경진이의 냉장고에는 사과가 한개 사라짐. 같은 냉장고이기 때문.

