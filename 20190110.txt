2019.01.10

cpp 맛보기 - 기본기능 2편 뒷부분

(복습)
소멸 변수에 대한 반환 타입



p37 비소멸 변수
1) 전역 변수 2) 정적 지역 변수 3) 함수 인자로 호출된 변수 4) 동적 할당된 변수  

레퍼런스 == 포인터 이다 라고 생각할 것.

x2는 안되지만 x1이 문장을 통해서 바뀔 수 있다.
피호출함수의 변수가 바뀌느냐 아니냐의 관점에서 해석해야함

p38 
RBR==RBA

p39
RBV 
변수의 값이 바뀌어야 한다면 이걸 쓰면 안됨.
즉, 바뀔 필요가 없는 상황에서만 써야 함.

p42 
밑에 rv2 --> v2 : 오타 수정

p43
RBV : 구조체에 관해서는 값을 복사하는 방식이므로 비효율적
그러나 const에 관해선 효율적

p44
배열의 요소의 주소값을 반환 : 배열 요소 포인터

p45
배열의 주소값을 반환 : 배열 포인터
const이기 때문에 ++(*ap1)[2];는 사용법에 있어서는 맞지만 실제로는 불가능함. 
참조는 가능함.

p46
정리

+) 비소멸 : RBV를 주로 사용, 배열의 경우엔 요소포인터를 사용한 RVA를 가장 많이 사용

[Operator Function]
p47
v1, v2가 바뀔리가 없다. 바꾸고싶지 않다면  CBV를 써도 되지만 여기서는 CBR를 사용. 구조체이기 때문.
main의 v1 과 v2가 바뀔지 안바뀔지 확신할 수가 없음. 그래서 const를 사용해서 확신시켜줌.
const가 빠지게 되면 오답임.

사라질 변수인데 RBA나 RBR를 쓸 수 없음. dangling이 발생하므로
그래서 RBV에서 인자 전달 방식 밖에 사용할 수 없음.

함수이름이 독특하다는 것말고 그냥 함수와 큰 차이는 없음.

(중요한 것) 인자 타입으로 가능한 것? 그리고 가능한 것들 중에 최선은?	--> 판단할 줄 알아야함.

함수처럼 사용해도 되지만 p48에서처럼 연산자처럼 사용해도 된다. 
연산자를 사용해서 호출하게 되면 함수 호출방식을 바뀌어서 컴파일 됨.

Operator Funcion은 함수 호출 방식, 연산자 호출 방식 둘 다 사용가능하지만 실제로는 연산자처럼 사용하기 위해서 만든 것임.
--> Operator Overloading 
(비유) 학생의 본분은 학업임. 아르바이트 하느라 공부를 안함. 그건 함수호출방식임.
	아르바이트 안하고 공부를 함. 그건  연산자방식.
그런데 가끔씩 함수호출방식만을 써야하는 경우도 생김.

p49
# 연산자 - 
1) 뺄셈 연산자(이항연산자_산술)
2) 부호 연산자(단항연산자_애꾸눈)
우선순위 : 1) < 2)

# !은 논리연산자이지만 단항연산자에 속함.

[Memory Allocation]
(비유) 은행에서 대출을 받음. 메모리가 부족해서 추가적으로 할당받음. 다쓰고 나면 상환해줌.

p51
오른쪽 : C언어에서는 이렇게 메모리 할당함.
근데 말그대로 메모리만 할당함. 뒤에 배울 생성자와 소멸자라는 걸 자동으로 해주는 기능을 내재하고 있지 않음.

그런데, 객체지향에서는 malloc에서 지원하지 못하는 이 추가 기능이 중요함.
속도는 malloc이 더 빠름. 근데 속도가 중요한 게 아님. 그래서 malloc은 비바람직. 
객체지향적으로 프로그램을 만드는 것이 중요.  (시대가 바뀌었음)


변수없는 C언어 타입으로 할당

# 공부잘하는 방법 == 백지코딩 
--> 자료에 있는 모든 코드 백지코딩 해볼 것.

[Function Overloading]
같은 이름의 서로 다른 함수가 여러개 --> C언어에서는 말도 안됨. (비유) 철수가 세명이면 철수를 호출하면 누가 대답해야할 지 모름.
그러나 C++에서는 허용. 단, 인자 타입이 다름.
(비유) 같은 철수더라도 면과 춘장을 주면서 철수를 호출하면 짜장면만드는 철수가 호출됨.

초창기에 C++은 C언어로 바뀌어서 컴파일 되었음.
Overloading의 경우에는 함수이름을 각각 다 다르게 바꾸어서 컴파일 됨.
(print --> print_int / print_double 이렇게)

[Default Argument]
언뜻 보면 Function Overloadin과 비슷하게 보임. 
그러나 겉으로 보이는 효과는 똑같아보이지만 구현 내용은 다름.
함수는 하나. 미리 값을 default해줘야 함.
인자 생략시에 default된 값이 적용되어 함수 호출.

컴파일시에 함수 호출부에서 빠진 인자를 넣어서 C언어로 바꾼 뒤에 컴파일.

함수 정의부가 호출부의 뒤에 있다면 호출 앞에다가 함수 선언을 해주어야 함.
단, 이 경우에는 default는 선언부에다가 해야함.

#include <iostream>

using namespace std;

void print(int a, int b=0, int c=0);

int main(void)
{
	print(1);
	print(1,2);
	print(1,2,3);
	
	return 0;
}

void print(int a,int b, int c)
{
	cout << a << ' ' << b << ' ' << c << endl;
}

그러나 이렇게 안하고 선언없이 정의로 대체하는 것도 가능.
------------------------------------------------------

변수 참조 선언
같은 변수에 대해서 선언을 여러번 하는 것. 
--> 문제 되지 않음.

단, default값이 정해져있는 변수를 여러번 선언하는 것(default arguement)은 문제가 됨. --> SE
(불일치는 아니지만 불일치의 가능성이 있다고 판단하므로)






















