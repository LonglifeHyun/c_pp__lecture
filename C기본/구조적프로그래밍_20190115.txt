구조적프로그래밍_2019.01.15

구조적 프로그래밍 7주차

[반복문을 사용한 자료의 처리]

*반복 조건 (용어자체를 잘 알아둘 것)
반복조건은 반복문의 첫 번째 if-break문으로 전환 가능

(형광등 비유)
for(i=0;true;++i)	==	for(i=0;반복조건;++i)
	if(!반복조건)
		break;

--> 탈출 조건으로 전환할 때는 문장의 순서를 잘 지켜야 함.

[for문의 탈출]
반복조건이 *범위 조건.
범위조건에서 true && 범위조건' 은 간소화 가능.
ex) beg<=i && i<=end	--> i<=end

반복조건 == !(탈출조건) == !(발견조건)

<for문을 활용한 자료의 처리 형태 >
1) 전체처리
2) 선택처리
3) 발견처리

(비유)
외계인이 지구에 침략을 목적으로 숨어들었음. 찾아서 없애야함.
범위는 i=beg; i<=end;
1) 전체처리
	외계인과 지구인은 잘 구분이 되지 않으므로 다 없애버림
	반복문을 다 돌고 난 후 i==end+1
2) 선택처리
	외계인의 특징을 골라내서 외계인을 찾아서 없애버림 
	특정 조건을 만족하는 값들만 처리하는 방법
	반복문을 다 돌고 난 후 i==end+1
3) 발견처리
	외계인이 있다는 말을 사람들이 믿어주지 않음. 있다는걸 한 놈만 잡아와서 증명하면 됨.
	수성부터 쭉쭉쭉 돌면서 찾음. 토성에서 찾았으면 잡아서 지구로 귀환하면 됨. 계속 돌면 바보임.
	(*발견조건을 발견하고 나면 반복문 탈출)
	(1) 순방향 검색 : 범위조건의 앞에서부터 --> 최소값을 구해야할 때
	(2) 역방향 검색 : 범위조건의 뒤에서부터 --> 최대값을 구해야할 때
	반복문을 탈출하고 난 후 i
		발견 성공 : beg<= i <=end	(비유) 여행을 일찍 끝냈으므로 우주복이 깨끗.	
		발견 실패 : i==end+1		(비유) 태양계를 벗어남. 발견실패임. 우주복이 더러움.
							발견을 했어도 태양계가 아닌 안드로메다의 착한 외계인이므로 실패.

< 발견처리에서 성공처리 >
for(초기화; 범위조건; 증감)
	if( 발견조건 ){
		성공처리문;
		break;
	}

< 발견처리에서 실패처리 >
for(초기화; 범위조건; 증감){
	if( !발견조건 ){
		실패처리문;
		break;
	}
--> 이런식으로 코딩하면 바람직하다.

(비유) 유치원생이 "인생 별 거 없네"라고 하는 것.
아직 인생 다 살아보지도 않고 "인생 별 거 없네" 라는 결론을 낼 수 없음. 
마찬가지로, for문을 끝내기도 전에 "not found"의 결론을 가질 수 없음. --> logical error

성공/실패 여부를 판단하려면 손에있는 외계인의 여부가 아니라 우주복이 더러운지의 여부로 판단 해야함.
즉, 발견조건이 true가 아니라 범위조건이 true인지를 확인해야함.

==> 성공 조건 == 범위조건	--> for문에서의 범위조건임.
    실패 조건 == !범위조건
범위조건이 아닌 발견조건을 사용하면 error.

#include <stdio.h>

int main(void)
{
	int beg, end;
	int i;
	
	scanf("%d%d", &beg, &end);
	for(i=beg;i<=end;++i){
		if(i%5==0){
			printf("found\n");
			break;
		}
	}
	if(!(i<=end))
		printf("not found\n");
	return 0;
}

--> 이 코드는 완벽히 숙지하도록. 
근데 이 코드는 산 위에서 "심봤다"소리치는 것과 같음. 아무도 못들음.

산 밑으로 내려와서 소리쳐야함. 
--> for문 외부처리. 내부에서 외부로 전환할 때는 성공처리의 조건문에는 범위조건이 들어가야함.
// 이것도 완벽히 숙지.
#include <stdio.h>

int main(void)
{
	int beg, end;
	int i;
	
	scanf("%d%d", &beg, &end);
	for(i=beg;i<=end;++i)
		if(i%5==0)
			break;
	if(i<=end)
		printf("found\n");
	else
		printf("not found\n");
	return 0;
}

break 없이 반복처리문을 구현 할 수있다.
단, break없는 발견처리는 외부처리만 가능.

[함수화]

p52
배열은 반환이 불가능.
그러나 메모리가 공유되므로 인자로 (비유)빈그릇을 주면 됨.

< 반환값의 의미 >
#include <stdio.h>

int search(int* a, int beg, int end, int value)
{
	int i;
	
	for(i=beg;i<end && !(a[i]==value);++i)
		;
	return i;
}

int main(void)
{
	int a[7] = {5,7,3,9,2,7,2};
	int i, beg, end, value;
	
	scanf("%d%d%d", &beg, &end, &value);
	i = search(a, beg, end, value);
	if(i<end)
		printf("found: index == %d\n", i);
	else
		printf("not found\n");
	return 0;
}

=================================================================================
구조적 프로그래밍 8주차

[for문의 전환]
break와 continue는 사용하지 말고 코딩하는 것이 바람직.

문장이 먼저 나오고 발견조건이 나오면 문장과 함께 모듈화(함수화)를 할 것.

[수열의 입력] --> 세 가지 방식은 꼭 할 줄 알아야 함.
즉시 처리 : 값을 입력받고 바로 처리.

간접 길이 : 입력 실패시까지 입력받음. (비유) 교수님이 성국이한테 밥을 사주다가 돌멩이를 사줌. 그럼 성국이는 그만옴.
직접 길이 : 최대 입력의 길이를 미리 정해놓고 시작. 중간에 실패시 종료.
고정 길이 : 정해진 횟수만큼 꼭 반복문을 수행해야함. 
	(비유) 성국이는 세 번 밥을 먹어야 졸업을 할 수 있음. 그런데 교수님이 돌멩이를 줌. 성국이는 학업을 멈추고 시위를 함.
		교수님이 오지말라고 펀치를 날림 그것도 시위를 해야함. (EOF)
 
일괄처리 : 값을 받아서 저장하고 있다가 한꺼번에 처리.

처음부터 배열의 길이를 정해놓고 시작하는 것 --> 최대 할당 방식.
C99부터 실행도중에 배열의 길이를 정하는 것이 가능해짐. --> 최적 할당 방식.

[수열의 조작]_ 여기 있는 코드는 싹 다 외울 것.
1) 순방향, remove with Tail-replacement
	앞에서는 index를 주고 제거하는 수열의 조작이었는데 지금은 값을 주고 제거하라고 함.
	값에 해당하는 index부터 찾아야함. 발견처리를 해야함. 발견처리도 앞에서 배움.
2) 순방향, remove with Step-forward
3) 역방향, remove with Tail-replacement
4) 역방향, remove with Step-forward
5) self-append, 원하는 값 모두 제거.
	p21 i : 원천 수열의 index, j : 목적 수열의 index
	쓸 데없이 다른 배열을 할당해서 하지 않도록! self로 충분함.
6) 중복 제거
	p23 self-append
#include <stdio.h>

int main(void)
{
	double a[100] = {1.1, 2.2, 3.3, 2.2, 1.1};
	int len = 5, i, j, k;
	
	for(i=0, j=0;i<len;++i){
		for(k=0;k<j && !(a[k]==a[i]);++k)
			;
		if(!(k<j))	// "앞에 append 해놓은 것이 아니면" 이라고 문맥적으로 해석 할 줄 알아야함.
			a[j++] = a[i];
	}
	len = j;
	
	for(i=0;i<len;++i)
		printf("%g ", a[i]);
	printf("\n");
	return 0;
}

< 연습 >
# 코딩은 쉽게 하고, 그걸 간단하게 전환할 줄 알아야 함.

p28 
 4진법이라고 생각하면 그다음 수를 출력하는 코드임.

p29
십진법

* backward
* a[i]==9: a[i]=0; continue
* a[i]!=9: ++a[i]; break;
--> 헷갈리지 않게 이거 꼭 적어놓고 전환하자.
# 고수는 헷갈리지 않음.

다음과 같이 초고를 써놓고,

for(i=sz-1;i>=0;--i){
	if(a[i]!==9){
		++a[i];
		break;
	}
	if(a[i]==9)
		a[i] = 0;
}

다음과 같이 고칠 줄 알아야 함.

for(i=sz-1;i>=0 && !(a[i]!=9);--i)
	a[i] = 0;
if(i>=0)
	++a[i];

< Prime Number >
prime number의 조건 : 약수를 발견하지 못하면 소수.
+) 보강 조건 : 1이하의 수는 소수가 아니다. 

p41 
!(x<n) : "약수를 발견하지 못했다"라고 해석할 줄 알아야 함.































