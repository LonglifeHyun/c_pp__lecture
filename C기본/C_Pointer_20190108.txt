C_Pointer_2019.01.08

C언어 포인터 part2_뒷부분

[명시적 타입 변환 & 묵시적 타입 변환]	// C언어 기본 강의 참고

< 명시적 타입 변환 >
연산할 때 피연산자의 타입을 일치시켜야 함. 불일치 시에 SE 발생하는 것이 기본.
예외 ) 	double* + int --> double*
	double* - double* --> int
Type casting operation : 불일치 하는 타입을 일치시켜주는 연산자
(ex) 
3 : 0000 0000 0000 0000 0000 0000 0000 0011
3.0 : 0 100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000

1.7 + (double)3
1.7 + 3.0

# bitwise연산을 이용해서 3 -> 3.0으로 바꾸는 프로그램을 만들 줄 알아야함.
int형으로 표현 되어있던 걸 double형의 표현으로 바꾸어서 ALU에 넣어줘야함. 

type casting operation이 대신 해줌.

int를 float로 바꾸는 이유? 소수점 이하자리를 보존하기 위해서 

< 묵시적 타입 변환 4개 >	// 상식의 기준
1) 정수 < 실수
2) char, short  --> int
3) 작은 거  -->  큰 거 : 큰 게 장땡이다!
4) signed < unsigned

--> 컴파일러가 프로그래머 대신 타입 캐스팅 연산자로 명시적 타입 변환을 해줌.

제 1원칙) 정수 < 실수
	f + ll;	// long long이 8bytes임에도 4bytes인 float로 바뀜. --> 계급사회 (우선순위 : float_귀족 > long long_평민)
제 2원칙) char, short --> int
	char + char --> (int)char + (int)char --> int
	type이 같은데도 불구하고 int로 타입 캐스팅 되어서 연산이 되는 이유?
		이를 이해하기 위해선 CPU구조를 이해해야함. 
		데이터가 ALU에 들어가기 위해서는 register를 통해야함. 이 register는 int타입임. 따라서 int로 타입캐스팅됨.
제 3원칙) 작은 거 --> 큰 거 // 평민 끼리 붙으면 나이 많은 사람이 이김.
	같은 종류의 타입(정수 / 실수)에 대해서 크기가 큰 게 작은 걸 이김.

제 4원칙) singed < unsigned
	크기로 보면 메모리공간의 크기는 같지만 unsigned가 우세.

#include <stdio.h>

int main(void)
{
	unsigned i;
	
	for(i=2;i>=0;--i)
		printf("%d\n", i);
	return 0;
}

==> LE. 무한 루프를 돌게됨. i의 값이 2, 1, 0 이후에 underflow가 발생. unsigned int 의 최대값 (2^32-1 == 대략 40억)

+) Overflow : 1111 --> 0000
   Underflow : 0000 --> 1111

#include <stdio.h>

int main(void)
{
	unsigned i;
	
	for(i=2;i>-1;--i)
		printf("%d\n", i);
	return 0;
}

==> LE. 조건문을 만족시키지 못해서 for문을 한번도 돌지 않음. 
	-1은 signed int. i는 unsigned int. 묵시적 타입 변환. 
	(unsinged)-1 == unsigned int 의 최대값 (2^32-1 == 대략 40억) 
	// 2의 보수로 표현 체계에서 unsigned int 표현 체계로 바뀜. 즉, 1111 을 2의 보수로 해석하다가 unsinged로 해석하게 됨.

# 교수님 강의 자료엔 몰라도 되는게 없음. 이런 세세한 것까지 다 완벽하게 숙지하고 있어야 함.  --> 스승을 뛰어넘어야 함. 
------------------------------------------------------------------------------------------------------------------------------
< 묵시적 타입 변환 >
제 5원칙 : 배열의 묵시적 타입 변환

p29
제 6원칙 : 대입 연산자의 묵시적 타입 변환
	L-value와 R-value의 타입을 자동으로 일치시켜줌. R-value가 크든 작든 무조건 L-value의 타입을 따름
	ex) double d = 3;	--> 	double d = (double)3;
	    int a = 3.14;	-->	int a = (int)3.14;	a = 3;	// 소수점 이하의 값이 짤림(truncation)
		truncation해도 무방한 경우가 있음. 컴파일러는 프로그래머의 의도라고 생각함. 
		하지만 프로그래머가 착각했을 수도 있음. 불안함 --> warning 발생시킴. "야, 프로그래머! 니 착각한 거 아님?" 
		그런데 int a = (int)3.14;라고 코딩을 하면 프로그래머의 의도가 명확함. 바람직한 코딩.
3.14 타입 : double	// 3.14 값의 종류 : 실수
float a = 3.14;		// 3.14의 타입 == double 
--> 데이터 손실이 없을까? 모르지. 있을 수도 있음.

10진수로 유한소수인데 2진수로 바꾸게 되면 무한소수가 되는 경우가 존재. (역은 없음)

double이 많이 표현. double --> float로 바뀌면서 유효숫자가 짤려서 데이터 손실이 발생할 수도 있음.
(비유) 넓은 데서 좁은 데로 이사가는 것임. 짐을 일부 버리고 가야함.

그래서 안짤리게 하려면 float a = 3.14f;로 3.14를 float타입으로 정해놓으면 됨. 	//3.14F;해도 됨.
--> 유효숫자가 짤리지 않음.

double d = 3.14f;	// float타입이 double타입에 저장됨. (비유)좁은 데서 넓은 데로 이사가는 것임. 유효숫자 안짤림.

*넓은 데서 좁은 데로 갈 때에는 데이터 손실의 위험이 있으므로 묵시적으로 쓰지 말고 명시적으로 쓰도록 할 것.
 
# 달국이는 진짜 완벽하게 숙지 돼있구나. 신기하다. 나도 그렇게 되자.

p30
reference 타입이 다름 : C언어에서는 warning. 그러나 C++에서는 위험한 것으로 판단하고 SE발생.
쓴다면 명시적 타입 캐스팅 ㄱㄱ
(비유) 누가 식칼을 들고 다님. --> 경찰이 경고로 끝냄.	// p29의 예
	미국에서 누가 총 들고 다님. --> 경찰이 잡아가지않음.	// C언어
	한국에서 누가 총 쏘면서 들고 다님. --> 경찰이 잡아감.	// C++

p31
[void pointer]
(비유)
예동이는 교수님의 집 주소임 장전동 100번지를 저장하고 있음. *예동이는 교수님일까? 알 수 없음. 
레퍼런스 타입인 예동이의 타입이 중요함. 
T(예동이) == 할머니* : *예동이--> 교수님 어머님. 
T(예동이) == 교수님* : *예동이--> 교수님. 

주소만 안다고 해서 값을 해석 할 수는 없다. 참조 타입도 함께 줘야함.
여기서 타입의 정의의 이유를 알 수 있음. 1)값의 표현 방식 2)메모리 공간의 크기

p32
참조타입을 정할 수 없는 포인터 변수에 *마법모자를 씌우면 SE. 해석할 수 있는 정보가 없음.
덧셈, 뺄셈 연산도 마찬가지.

int a = 3;
void* p = &a;
*p	// SE
p+1	// SE

포인터의 목적 : 저장한 주소값에 *마법모자를 씌우기 위함임. 안씌울거면 왜만듦?

그런데 void*은 *모자를 씌울수 없는 포인터임. 왜 만듦?
어차피 나중에 타입 캐스팅 할 바에야 처음부터 int*/char*등등 으로 해놨어도 되잖아. 굳이 왜 void*라는 걸 만들었어?
진실 : 초창기 C언어에서는 실제로 void*없이 char*을 사용했음.
그럼에도 만든 이유?	
int a = 3;
char* p = &a;	// 컴파일러 입장에서는 불안함. warning을 띄움. 

int a = 3;
void* p = &a;	// warning을 띄우지 않음.
	: 주소값을 저장할 때 타입캐스팅 연산자가 필요없음. 

==> void* 크게 유용한 건 아님. 아예 C++에서는 필요없음. 비야네 스트롭스트룹은 그냥 쓰지 말자고 함.
# 근데 사람들이 꽤 쓰긴해서 알긴 알아야 함
-----------------------------------------------------------------------------------------------------------------------
[(대망의)함수 포인터]
p33
 함수 : 명령의 목록이 저장되어 있는 *메모리 공간.
 변수 : 값이 저장되어 있는 *메모리 공간.
프로그램(Software)은 변수&함수(메모리 공간)로 구성되어 있다.

# 이렇게 정의하는 이유는 포인터를 설명하기 위함임. 메모리 공간이기 때문에 주소를 가짐.

* 생각해 봐야할 점

 변수 = 주소 + 값
 값 = 의미가 부여된 이진자료. 이진자료 + 타입
 타입 = 표현방식 + 메모리공간의 크기	

->	함수 = 주소 + 명령
 	명령 = 이진 코드 + ISA

여기서 함수의 구성요소를 생각해봐야함.
표현방식은 표준임. 전세계에서 모두 표준을 사용하기 때문에 특정 하드웨어에 종속적이지 않음.
ISA는 표준이 아님. 하드웨어에 종속적인 소프트웨어가 됨.
이는 HLL(High Level Language)의 이식성에 위배됨. 고급언어는 하드웨어에 독립적인 것임
 --> C언어가 HLL로서 가지는 가치를 상실. : 하드웨어에 의존적인 프로그램이 됨.

그러므로 함수의 구성요소를 재정의.
 *함수 = 주소 + 함수타입

ex) void f(int v) --> T(f) == void(int)

p = &f;		// T(p) == void(int)*	: 개념적 타입 	--> 	void	(*p)(int);

p34
함수의 크기는 존재하는데 크기가 존재한다고 말할 수 없음. 하드웨어에 의존적인 프로그램이 되기 때문.
--> 함수의 크기를 구할수도 없고, 활용할 수가 없음. 
sizeof연산을 하게 되면 SE.

< 묵시적 타입 변환 >
제 7원칙 : 함수의 묵시적 타입 변환

# 모든 묵시적 타입 변환의 조건 : 1차적 오류(SE)가 발생해야함. --> 컴파일러가 대신 조정해줌.

제 5원칙 : 1) SE  2) array
	a    --> &a[0]
	X[N] --> X*		// [] --> *
제 7원칙 : 1) SE  2) function
	f      --> &f		// 앞에 &가 보여야함.
	RT(AR) --> RT(AR)*	// * 추가

(): 함수 연산자 ("뭐? () 얘가 알고보니 연산자라고?!?!?! 이런 막장드라마?!?!?!?")

 연산자 우선순위 제일 높은 어벤져스 중에 하나임 .(헐크) ->(토르) [](아이언맨) ()(캡틴 아메리카)
 
# 수식결과로 변수를 가지는 연산자 : *(마법모자) .(헐크) ->(토르) [](아이언맨)

배열 연산자 사용 : 주소[인덱스]
함수 연산자 사용 : 함수주소(인자목록) --> 반환 값

T(p) == void(int)*	-->  RT(p) == void(int)
p의 종류 : 포인터

p는 reference는 존재하지만 크기가 존재하지 않으므로 덧셈, 연산은 불가능 --> SE
(사실은 있는데 없다고 우기기로 했잖아!)

#include <stdio.h>

int f(int i)
{
	return i*i;
}

int main(void)
{
	int (* p)(int) = &f;
	
	printf("%d\n", (*p)(3));		// (1) 
	printf("%d\n", p(3));			// (2)
	printf("%d\n", f(3));			// (3) 가장 많이 쓴 방식. 묵시적 타입 변환에 의해 (4)처럼 바뀌어서 컴파일 됨.
	printf("%d\n", (&f)(3));		// (4) original
	return 0;
}

--> (1)~(4)는 모두 같은 표현임.
------------------------------------------------------
printf함수도 마찬가지.

#include <stdio.h>

int main(void)
{
	int (*p)(const char*, ...)	= printf;
	
	(*p)("Hello, World.\n");
	p("Hello, World.\n");
	printf("Hello, World.\n");
	(&printf)("Hello, World.\n");	// original
	
	return 0;
}
--------------------------------------------------------
This is TRUTH
#include <stdio.h>

int main(void)
{
	int a[3] = {11,22,33};
	int i;
	int (*ap)[3] = &a;
	int* ep = a;
	
	for(i=0;i<3;++i)
		printf("%d ", a[i]);
	printf("\n");	

	for(i=0;i<3;++i)
		printf("%d ", ep[i]);
	printf("\n");

	for(i=0;i<3;++i)
		printf("%d ", (*ap)[i]);
	printf("\n");
	
	for(i=0;i<3;++i)
		printf("%d ", (*(&a))[i]);
	printf("\n");
	
	for(i=0;i<3;++i)
		printf("%d ", (&a[0])[i]);
	printf("\n");
	
	return 0;
}

=================================================================

#include <stdio.h>

void f(char (*a)[14])
{
	int i;
	int len = sizeof(*a) / sizeof(**a);
	for(i=0;i<len;++i)
		printf("%c", (*a)[i]);
}

int main(void)
{
	char a[] = {72,101,108,108,111,44,32,87,111,114,108,100,10,0};		// "Hello, World\n";
	f(&a);
	return 0;
}

// 이건 야매임.. 

#include <stdio.h>

void f(char (*a)[15])
{
	int i, len = sizeof(*a) / sizeof(**a);
	for(i=0;i<len;++i)
		printf("%c", (*a)[i]);
}

int main(void)
{
	f(&"Hello, World!\n");
	return 0;
}
 
// 이게 진짜!

==================================================================
p37 --> 중요. 시험

int(int,int)*[2] fl = {&add, &sub};
int (* fl[2])(int,int) = {&add, &sub);
int a,b;

p38 --> 인강 참조 (시험엔 안나옴)


==================================================================================================================
C언어 _ Pointer Part3(개념적 타입)

[개념적 타입]

*타입 분류 5가지
1) 기본
2) 배열
3) 구조체
4) 포이터
5) 함수

p5
int(char,int)[4] --> error
겉으로 보면 array이지만 그 구성 요소는 함수
왜냐면! 배열의 정의(같은 타입의 연속된 변수들의 복합 변수)에서 보면 구성요소가 함수가 아닌 변수들이어야 함

반환 타입은 반드시 값. 구조체도 원래는 안되는데 최근들어 허용.

p6
*포인터 타입일 경우 참조타입에 주목해야함.
5가지 타입 모두 참조 타입이 될 수 있음.

p7
배열일 때는 요소타입에 주목해야함.
배열의 요소타입으로 함수는 불가능! --> ERROR 

뒤에는 개념적 타입   <-->   C언어 타입 에 대해 쭉 설명 있음. 

p12
변수가 없을 때는 임시변수 삽입해서 ㄱㄱ

[타입 재정의]
앞에 쉬운건 넘어가고 p27

복잡한 타입의 재정의 --> 밑에서부터 차근차근 풀어보면 다 된다.










