2019.01.07

cpp 기본기능 2


[ 배열 길이 전달 방법 ]

(복습_C_Pointer)
배열요소 포인터를 함수로 전달할 때 배열의 길이는 전달하지 못해서 배열 길이 연산 방식으로는 배열의 길이를 구할 수가 없다.
그래서 다음의 네 가지 해결 방법이 있는데 각각의 장단점을 잘 알아둘 것.

1) 전역변수
2) 상수값
3) 인자
4) 종료값(delimeter)

p5

5) 배열 포인터를 이용 (배열 길이 전달)
 배열 포인터 --> 배열이 아직 녹아있음 --> 배열 길이 연산 방식 사용가능 : 배열 요소 포인터의 단점을 보완 
 단, 고정된 길이에서만 처리 가능. (인자에 배열의 길이가 정해져있기 때문)

그러나, 이 배열의 길이를 구할 수가 없는 부분이 장점이 되기도 한다. (배열요소포인터의 단점)
(비유) 마치 발목이 없는 장애인이 특수한 장치를 이용해서 육상선수가 되기도 함.

< 배열 요소 포인터의 장점 >
1) 배열처럼 쓸 수 있다.
2) 배열의 길이 정보를 사라지게 함으로써 어떠한 길이의 배열이라도 다 사용가능하다는 장점도 있다.
-->  이 장점으로 인해서 같은 배열길이 전달의 방식이더라도 2) ,5) 중에서 5)의 방식보다는 2)의 방식을 더 많이 사용한다.

그러나 거의 쓰이지 않음에도 5) 의 방식은 꼭 알아야한다.


p8

6) 구조체 활용
 CBV의 방식이 생겼음에도 CBA의 방식이 더 효과적이기 때문에 여전히 CBA를 많이 씀.  
 CBV : 데이터가 크므로 복사를 하는데 시간이 많이 걸림

 여러가지 장점. (놓쳤다ㅠ) 
 그러나 별도로 구조체 타입을 선언해야한다는 단점. --> 사용 빈도가 낮은 방법.

 --> 별도의 타입 선언이 없다면 굉장히 좋은 방법임. 
	==> C++에서 만들어놓음(STL)  -->  편리하게 프로그래밍을 할 수 있음.

p9
함수 호출 -> 반환값을 남기고 사라짐 -> 함수 안의 변수 a도 사라짐
즉, p는 죽은 a를 가리키고 있음. dangling pointer.  (비유) 유령 교수님 예시. 
그러나 가리키는 것 자체는 문제가 되지 않음. 거기에 *마법모자를 씌우는 것이 문제가 됨.

따라서, p9처럼 코딩하는 것은 바람직하지 않음.
문법적으로는 printf문만 없다면 문제가 없을지 몰라도 애초에 dangling pointer를 만들어 내도록 코딩한 것이 비바람직.

p10
전역변수는 함수가 끝나더라도 살아있음 --> dangling pointer가 아님.

p11
전역변수와 마찬가지

p12
메모리 할당된 것도 해제되기 전까지는 마찬가지. 단, 해제 해야한다는 번거로움이 있긴 함.
 단점 : free해야 할지, 말아야 할지 결정하기 위해서는 함수의 동작을 이해해야함 --> 유지보수에 불리 --> 잘 사용되지 않음
 	동적 할당된 변수 인줄 알고 실수로 해지 했는데 알고보니 전역변수였다면 난리남.
   
# 결자해지 : 일을 시작한 사람이 끝내야한다. C++에는 garbage collector가 존재하지 않음.
		그래서 이 결자해지를 불가하게 하는 코딩을 달가워하지 않음.
# garbage collector : 전체 프로그램을 총괄하는 사람. 엄청 smart한 사람이 이어야 함.

p13
함수 인자로 사용된 메모리 주소. 
main함수의 지역변수. 함수가 종료되었다 하더라도 지역변수는 살아있음.
--> 문제 되지 않음.

[Return 할수 있는 변수] _ 요약
1) 전역 변수 --> 웬만하면 X
2) 정적 지역 변수 --> 많이 쓰임. (그러나, side effect가 있으므로 남용해서는 안됨)
3) 동적 할당된 변수 --> 쓸순 있지만 바람직하지 않음.
4) 인자로 사용된 변수 --> 많이 쓰이지 않음.

# 프로가 되기 위해서, 바람직한 코딩을 하기 위해서는 이 모든 것의 장단점을 다 숙지 하고 있어야 함

p14
[***함수 인자 전달 방법] --> 객.체.지.향.

# 초대형 소프트웨어 개발을 위해서는 객체지향이 꼭 필요함.
 구조적 프로그램으로 초대형 소프트웨어를 개발하다보면 Software Crisis. (Windows98 사건)

# 고급언어(HLL)가 탄생한 배경 
	1) 기계어, 어셈블리어에 비해서 사람이 이해하기 쉽다.
	2) 기계어, 어셈블리어에 비해서 이식성이 높다.
	--> 그러나 초반에는 하드웨어를 정교하게 관리하는 고급언어가 없었다.
  (비유) 내가 왕인데 전라도 도지사한테 명령을 내리고 싶은데 방법?
	소리지를 순 없음. 성국이를 보내자니 못믿겠음. 옥새를 찍어서 문서를 성국이에게 전달하라고 함. 성국이는 변조 불가능.
	--> 따라서 나라를 다스리는 방법은 문서. 현재도 마찬가지임.
   마찬가지로, DMA방식 : CPU는 RAM를 통해서 주변 장치들을 통제 함. --> Computer Structure에서 배울 예정.
   그런데, 왕이 글을 쓸 줄 모른다? 성국이 나라임. 이름처럼 나라를 세웠구만 아주? 
   그러니, 나라를 다스리기 위해서는 글을 필수로 알아야함.

   프로그래머도 마찬가지임. --> HLL + MM를 건드릴 능력(Pointer) ==> C언어 탄생(OS 개발에 적합)

# 버퍼링 : 버퍼에 데이터를 저장하는 과정에서 시간이 지연되는 현상

# Windows98 사건
 C언어로 작성된 대략 10,00,000 lines 의 코드.
 분석하라고 사장님이 시킴.. 너무 많잖아...?!
 사장님 "열심히만 하면 뭐합니까 잘해야죠" 짤림.
 그래서 대충 수정. 그런데 연결 돼 있던 건들인줄도 모르고 수정하면 난리난리난리나~
 문제 생기니까 그냥 새로운걸 만들어서 떔빵함. 계속 수정될수록 땜빵이 커짐.
 유지보수해서 써야하는 건데 더이상 보수할 수 없을 정도가 됨. 
 --> Windows98 폐기
 --> 반복 
 --> Software Crisis!!

# Software Crisis에서 확인할 수 있는 C언어의 구조적 프로그래밍의 문제점
 서로 간의 dependancy를 기술하지 않으므로 유지보수가 힘들어짐.
--> 서로 간의 dependancy를 기술하는 객체지향이 등장하게 됨.
	수정해야 할 부분이 있다면 해당 부분들만 보면 됨. --> 유지보수에 유리

[객체지향]
1) Encapsulation
2) Inheritance
3) Polymorphism


# 개매운치킨은 앞으로 수업전날 먹지마라 ㅡㅡ

p14

[잠시 화장실 간 사이에 성국햄이 대신 필기해주신거]

C언어에서는 const 와 non-const에 대한 구분이 중요하지 않은 코딩을 가르쳤는데, C++에서는 그렇지않다. 굉장히 중요한 개념이다. 사실은 근데 C언어에서도 중요하긴 중요한데, 현재 C언어 코딩하는 대부분의 프로그래머들이 구분을 잘 해주지 않기 때문에, 그리고 옛날에 코딩된 프로그램들도, 심지어 C언어 창시자인 데니스 리치 마저도 구분을 하지 않기 때문에 대부분의 C언어 프로그래머들이 구분하지 않지만, 사실은 구분해주는게 바람직하다. 왜 그런지 고민해보자.
 우리는 함수를 쓸때 CBV를 쓸지 CBA를 쓸지 고민해야한다. 값을 바꿀거면 CBA를, 안바꿀거면 CBV를 사용하는게 바람직하다고 교수님이 누누히 이야기하셨었다. 저번에 C언어 특강떄도 이야기 하셨지만 CBA를 쓴다고 해서 반드시 바뀌는건 아니다. 바뀔수도 있고 아닐수도 있다. 근데 안바뀌면 뭐다? 바보같은 코딩이다. 왜냐면 안바꿀거면 CBA를 쓸 이유가 없기 때문에. 그 이야기 하시면서 교수님이 비유 드셨던게 혜교랑 중기랑 대로쪽으로 갈지 샛길쪽으로 갈지 고민하는상황에 대한 비유였다. 둘이 만약 샛길로 갔다면 립스틱 색이 바뀌었을까? 원론적으로 본다면 반반이지만 확률적으로 본다면 99퍼 바뀐다. 안바뀌었으면 뺨맞는다. 뭔가 기대를 하고 갔는데 기대를 만족하지 못할경우 혜교가 뺨치고 헤어지자고 할거다. 
 코딩도 마찬가지다. CBA를 썼다면 바꿀것을 기대하는데 안바뀌었다면 멍청한 코딩이다. 왜냐? 바꾸지 않을거면 CBV가 더 좋은 코딩방식이기 때문이다. 왜 저게 더 좋냐면 CBV를 쓴다면 함수 내부를 굳이 보지 않아도 안바뀔것을 알기 때문에 유지보수 및 코드 분석이 더 쉬워지기 때문이다. 혜교도 차라리 중기가 대로로 갔으면 뺨은 안때렸을거다.
 구조체를 보자. 만약 우리가 함수 인자로 전달한다면 주소값을 전달할수도 있고, 뒤늦게 허용된 CBV방식을 사용할수도 있다. 근데 이 경우에는 CBA가 항상 더 바람직하다. 왜냐하면 대로가 대로가아니라 엄청 돌아가는 대로고, 샛길은 직선으로 가는 지름길이기 때문이다. 그렇다면 구조체에 대해 CBA를 택했다는건 무슨뜻일까? 무슨뜻인지 모른다. 길이 빨라서 갔을수도있고, 립스틱 색을 바꿀려고 갔을수도 있는거기 때문에. 
 그렇기 때문에 이 경우(구조체 CBA 사용) 고민이 된다. 립스틱 색을 바꿀려고 하는건지 빨리갈려는건지 가보지 않으면 모르기 때문이다. 마찬가지로 코드도 함수를 들여다보지 않으면 바꾸는건지 아닌지를 모른다. 그렇다면 이걸 미리 알 수는 없을까? 알 수 있다. 어떻게 해야할까?
-------------------------------------------------------------------------------------------------------
사람들의 기대심리를 만족시켜야지! 
안바꿀거면서 바꿀것처럼 코딩하면 0점처리 됨 


CBA로도 충분한 일을 CBR을 굳이 등장 시킨 이유? 좀 더 세련되게 보임. 그이유 하나임. 
--> CBA 와 CBR은 거의 동일한 것으로 볼 것. 그런데 앞으로는 굳이 CBR을 사용하도록 하는 것이 더 낫다.
   (이왕 쓰라고 만들어 놓은거 써야지)

# C언어에서 변수의 종류
 기본
 배열
 구조체
 포인터

--> C++에서 변수의 종류
 기본
 배열
 구조체
 포인터
 레퍼런스(근데 곧 포인터임)
--------------------------------------------------------------------------------------------------------------------------------
[기본 타입]
p15
최대 관심사 : main함수에서의 지역변수들이 함수를 통했을 때 바뀌는가 아닌가!
CBV이므로 값이 변경되지 않음. 
--> main함수입장에서는 const인지, non-const인지 중요치 않음
--> 어느 것을 쓰든 무방. 그럼 나라면 non-const써서 가독성을 높일래. 근데 const 써도 됨!

# const를 쓰는 이유? 
 바뀌지 않아야 할 값이 바뀌었다면 const를 이용해서 SE로 미리 걸러내서 사전에 예방하기 위함임.

# 야 딴생각하지마라

p16
바꾸겠다고 코딩했으면 바꾸고,
안바꿀거면 바꿀것처럼 코딩하지마라. 
근데 안바꿀거면 CBV를 쓸 듯.

p17
CBA와 거의 유사. 그런데 C언어에서는 함수 호출부만 보고도 CBV인지 골라낼수 있었는데, 
C++에서부터는 CBV와 CBR와 구분되지 않음. 그래서 함수 정의부까지 함께 봐줘야 함.

==> 기본타입인데 안바꿀거면 CBV를 사용할 것. --> 바람직한 코딩

[구조체 타입] 
p18
CBV : 어차피 바뀌지 않음. const/non-const는 의미가 없다.  그러나 비효율적.

p19
바꿀거면 non-const :안바꿀거면서 이거쓰면 뺨맞을 일임. 
안바꿀거면 const

p20
CBA와 같은 것임. 다만 좀 더 세련된 것임. 그러니까 CBA를 쓸 상황에 CBR를 사용.

p21
배열은 외길임
CBA밖에 없음.
그런데, 정말 묘한 방법이 하나가 더 있음.
배열자체는 복사가 안되는데, 구조체에 넣어서 구조체 복사를 통해 배열 복사하는 방법이 있음
--> S-CBV : S는 어차피 안바뀜. const/non-const는 의미가 없음. 

[배열]
p22
배열의 외길.
배열 요소포인터 쓰는 CBA.	--> 배열에 대해서 제일 많이 쓰는 방식. const / non-const 구분이 중요. 
바뀔거 같으면 non-const :안바꿀거면서 이거쓰면 뺨맞을 일임. 
안바뀔거 같으면 const

그런데 이건 배열의 길이전달에 있어서 단점이 있음. 그에 관한건 앞에서 배웠음.

p23
배열포인터 쓰는 CBA
--> 나쁘지 않은 방법이지만 고정길이에서만 사용되므로 같은 const방식을 쓰는 요소포인터 방식이 더 편리하기 때문에 낫다고 평가됨.
 
p24
*고정길이라면 CBR도 나쁘지 않음.
고정길이가 아니라면 좋은 방법이라 볼수는 없다.

==> 배열요소포인터를 쓰려면 const/non-const를 잘 구별할 것.

p25
[CALL에 관한 이야기] 정리

p26
[RETURN에 관한 이야기]
mortal 변수 : 함수가 return 되면 사라질 변수
Immortal 변수 : 함수가 return 되면 사라지지 않을 변수  :  전역변수, 정적지역변수, 동적할당된 변수, 인자

< mortal 변수 >
RBV --> 가장 기본이 되는 방식
 서로간에 영향을 주지않기 때문...?

p27
mortal 변수에 대한 RBA --> dangling pointer 발생시킴
근데 실제로 RE보다는 LE가 더 많이 일어나는 이유?
  이미 그 주소값에 뭐가 있어서
--> 정말 찾기 힘든 에러가 됨. 주의해야함.

# Run-time Error의 본질
 운영체제가 해당 프로세스를 죽이는 거.
 CPU가 할 수 없는 걸 시키는 것.
 
# Run-time Error의 원인
	1) Divided by Zero.	(비유) 성국이가 교수님께 별을 따달라고 함.
	2) Memory access violation <-- 보안상의 이유로.	(비유) 성국이가 옆자리 수현이 커피를 몰래 가져가서 먹음.
  ==> 교수님( OS ) 이 칼을 빼들고 성국이를 찔러없앰. (RUN-TIME)


# 제일 고마운 에러? SE. 발견이 쉬움.
# 제일 위험한 에러? RE. 프로그램이 죽음. 그러나 문제 인지는 가능
# 제일 발견하기 힘들고 짜증나는 에러? LE. 문제가 있는지조차 인지하기가 힘들고 어딘지 찾기도 힘듦.

운영체제별로 RE로 만드는 프로그램이 있고, LE로 만드는 프로그램이 있다면 RE로 보는것이 합당!
--> 주의해야할 매우 중요한 점임.

p28
mortal변수에 대해 RBA나 RBR 동일함
(p28의 코드를 C언어로 고치면 p27과 동일함.) --> RE를 발생시키는 프로그램임.

==> 따라서 mortal vairable 에 대해서는 RBV만 가능.

p29 ~ p31
[구조체] 의 경우에도 mortal 에 대해서는 RBV만 가능.

p32
(비유) RBV : 짜장면을 만들어서 바로 입에다가 넣어줌.
(비유) 동적할당된 변수 : 그릇을 만들어서 짜장면을 전달. 단, 다먹고 나면 그 그릇은 잘 버려야 함.

이 둘다의 방법이 마음에 안든다면 처음부터 그릇을 전달 해주면 됨 : 인자전달 방법(CBA)

--> 배열에 대해서는 RBV가 불가능하므로 CBA를 방법을 사용하는 것이 일반적인 방법. 
	( 배열 포인터를 쓰는 CBA / CBR 방법도 있기는 함 )
p35
가능은 하지만 거의 안씀.

p36
[mortal변수에 대한 RETURN] 정리

수업끝
===============================================================================================================================
Immortal에 대한 내용! -> 더 중요!