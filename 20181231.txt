2018.12.31

실습과제 EX01 ~ EX08

CPP 맛보기 - 기본기능 1편

p3
C와 C++의 차이. C++에서는 cin, cout 사용

# C언어 창시자 Dennis Ritchie

# 학과에서는 C++98을 기준으로 배우지만 교수님 개인 의견으로는 C++11까지도 ok

# 통합개발환경은 골고루 다룰줄 알아야 함

[C++ 기본 틀]
 #include <iostream>

 using namespace std;

 int main(void)
 {
	return 0;
 }

 main함수는 반환하는 타입이 int이기 때문에 return 0;를 쓰는 것이 원칙이지만 지금은 생략하는 것도 허용

p4 
endl : new line + flush(즉각적인 출력)

CPU에 비해 주변 장치들이 너무 느림
그래서 RAM의 일부분을 입출력에 관한 buffer로 사용. 그 buffer는 video card와 키보드와 연결 돼있음.
그 입출력 장치들이 처리할 순간에 buffer에서 처리함. 그러나 느려서 혹은 다른 일을 우선으로 하느라 바로바로 안될 때가 있음.
이 때 우선으로 처리하게 운영체제가 명령을 하는 것을 flush라고 함.
flush : buffer에 있는 내용을 비움(output에 대해서 flush를 하는 것이 원칙)

using namespace std; 유무의 차이?
없다면 항상 앞에 std:: 을 붙여야함.
--> 가로 길이가 길어짐 
--> 가로 쓰기&읽기를 하는 입장에서 가독성을 낮추게 하고 실수를 유발할 여지가 있음.
그러므로 코드의 가독성을 높이기 위해서는 using namespace std;를 사용하는 것이 좋음.

# 가독성이 좋은 코드의 col은 가능한 한 100으로 제한 하는 것이 바람직.

# 같은 맥락에서 와이드 모니터는 문서를 읽기에는 부적합

# C++ 창시자 : Bjarne Stroustrup[비야네 스트롭스트룹]


p5
int a = 3;
double b = 4.56;
char c = 'c';
char d[5] = "abcd";
int* p = &a;

C언어에서는 출력을 위해 형식지정자를 정확하게 넣어줘야함. 잘못 넣게되면 run-time 혹은 logical error 발생.

printf("%d", a);
printf("%f", b);
printf("%c", c);
printf("%s", d);
printf("%p", p);

C++에서는 cout 을 이용해서 형식지정자 없이 출력이 가능.

printf : 가변인자 함수
printf("%d %d", a, b); : 이렇게 원하는만큼 인자의 개수를 늘릴 수 있음. 
원래 C언어에서 함수를 만들 때는 인자의 개수는 지정한만큼만 넣을 수 있음. 그러나 printf는 가변인자 방식임.
	int printf(const char* s, ...)	// 첫 번째 인자만 정해주고 그 뒤의 인자에 대한 처리는 해주지 않음.
	{
		//int i일수도..
	}

가변인자 함수를 만든 이유?
scanf와 printf 함수를 만들기 위해서 만든 개념임.

현대 프로그래밍에서는 가변인자 함수를 사용하는 것을 바람직하지 못한 것으로 간주함.
주고 받는 내용끼리 일치하지 않을 위험이 있기 때문. --> 안정성을 낮춤

그럼에도 함수 하나 호출시에 여러 인자를 한꺼번에 출력하는 것은 매우 편리함.

그래서 C++에서는 안정성도 높이면서 편리함도 갖추기 위해서 cout을 만들어내서 사용.

[cout] : ostream 타입의 구조체. iostream에 있음. 연산자 <<를 사용.

원래 C언어에서 << (비트와이즈 연산자)의 피연산자는 정수형이어야 하지만 C++에서는 허용.

# 수식 : 연산자와 피연산자의 나열. 반드시 결과로 값을 가짐.
--> C++에서는 수식의 결과로 값과 변수를 가지는 것으로 확대됨.

1 + 2 + 3 == 3 + 3 == 6 : 사실은 연산이 두번에 걸쳐서 일어나지만 결과값만 보면 한번에 연산 된 것처럼 보임.
--> 이러한 연산의 특징에서 cout의 연속 출력의 편리성을 고안해 냄. 즉, 한줄에 수식을 기술할 수 있음
"cout << 변수" 의 결과 == "cout"

ex) cout << a << ' ' << b << endl;
 == cout << ' ' << b << endl;
 == cout << b << endl;
 == cout << endl;

+ 피연산자의 개수를 고정 시켜서 가변인자를 사용하지 않음 --> 안정성

C언어에서는 어쩔수 없이 printf&scanf를 쓸 수 밖에 없지만 C++에서는 cout&cin을 쓰는 것이 바람직.

p7
[cin] : istream 타입. (주의: extern istream이 아님)
cout과 마찬가지로 가변인자를 사용하지 않아서 안정성이 있음.

scanf("%d", &a);	--> cin >> a;
scanf("%lf", &b);	--> cin >> b;
scanf("%c", &c);	--> cin >> c;
scanf("%s", &d);	--> cin >> d;

cout과 마찬가지로 연산의 결과가 cin 그 자체가 됨. --> 연속 입력이 가능해짐.

p9
[입력 상태 점검]

주목해야 할 거 : fail

# C scanf() 
scanf의 return 값은 아래의 총 세 개.		// 입출력 결과에 대한 강의 자료 보고 공부할 것.
1) positive	: input success
2) 0		: input fail
3) -1(EOF) 	: End of File(입력 종료)

-----------------------------------------------------------------------
#include <stdio.h>

using namespace std;

int main(void)
{
	int a;
	double b;
	int retv;
	
	retv = scanf("%d", &a);
	printf("retv = %d, a = %d\n", retv, a);
	
	return 0;
}
========================================================================
input : 1) 5(정수 : 성공) 	2)abc(문자 : 실패)	3)Ctrl+Z(EOF)

-------------------------------------------------------------------------
#include <stdio.h>

using namespace std;

int main(void)
{
	int a;
	double b;
	int retv;
	
	retv = scanf("%d%lf", &a, &b);
	printf("retv = %d, a = %d, b = %f\n", retv, a, b);
	
	return 0;
}

=========================================================================
input이 2개이므로 2개에 대한 성공 개수를 반환 
input : 1) 3 3.14 (둘 다 성공)	2) abc 3.14 (일부 성공)	 3) abc 3 (둘 다 실패) // 3)은 입력 buffer에 대한 내용을 이해해야 함.

"3 3.14\n"
	" 3.14\n"	3 --> a
	"\n"		3.14 --> b

"abc 3.14"
	"abc 3.14\n"	x --> a
	"abc 3.14\n"	x --> b

"3.14 2.17"
	".14 2.17" 	3 --> a
 	" 2.17"		.14(== 0.14) --> b

".14 2.14"
	".14 2.14"	x --> a
	" 2.17"		.14 --> b 	// 이렇게 될 것이라고 예상되지만 실제로는 x --> b
	동시 입력의 상황에서는 첫 번째 case에서 실패시 두 번째 case도 실패라고 간주

---------------------------------------------------------------------------------------
#include <stdio.h>

using namespace std;

int main(void)
{
	int a;
	double b;
	int retv;
	
	retv = scanf("%d", &a);
	printf("retv = %d, a = %d\n", retv, a);
	retv = scanf("%lf", &b);
	printf("retv = %d, b = %d\n", retv, b);
	
	return 0;
}

이렇게 하면 하나는 성공 --> 연속 입력
=================================================================================================

(비유)
동시 입력의 상황(심부름을 한 번 시킴)
수현이에게 학과사무실에 가서 정수하나 실수하나 가져오라고 시켰는데 실수 두 개가 있었다.
수현이는 정수가 없었기 때문에 실수도 가져가지 않음.

연속 입력의 상황 (심부름을 두 번 시킴)
수현이에게 학과사무실에 가서 정수하나 가져오라고 시켰는데 실수 두 개가 있었다.
수현이는 정수가 없었기 때문에 돌아감.
수현이에게 학과사무실에 가서 실수하나 가져오라고 시켰는데 실수 두 개가 있었다.
수현이는 실수를 가져감


fail() : 앞전에 입력받은 입력이 실패했느냐 아니냐를 판단하는 함수
eof() : 앞전에 입력받은 입력이 있느냐 없느냐 판단하는 함수	//(비유) 학과 사무실이 문을 닫은 상황
good() : good() 이 아닌 것들(fail, eof, bad) 중 한개라도 true이면 false.
	 good()이 false일 이유는 어느 것일지 모름.



-----------------------------------------------------------------------------------------------------
#include <iostream>

using namespace std;

int main(void)
{
	int a = 99;
	char b[10] = "xx";
	
	cin >> a;
	if( cin.fail() ) {
		cout << "First Failure" << endl;
	}
	
	cin >> b;
	if( cin.fail() ) {
		cout << "Second Failure" << endl;
	}
	
	cout << "a: (" << a << ")" << endl;
	cout << "b: (" << b << ")" << endl;
	
	return 0;
}
========================================================================================================

(비유) C++로 넘어오면서 cin수현이의 성격이 변함(삐뚤어짐)
연속 입력으로 보냈는데 처음의 입력이 실패면 다시 보내도 안감. --> 다음 입력에 차질을 줌
다시 보내고싶으면 달래줘야함 --> clear를 해서 입력 상태를 good상태(!fail && !eof && !bad)로 만들어 줌.

# cin 이 scanf에 비해 까칠한 이유는 다음에..

p10
표 중요!
good() : !fail && !eof && !bad  // 사실상 굳이 필요는 없음

"123\n" : good() : !fail && !eof && !bad --> true
"123<EOF>" : 키보드 상에서는 불가능하지만 file입력(input.txt로 입력) 상에서는 가능함.  
	     즉, 123이 정수값으로 받아짐. eof이 true임에도 *최종성공.
	     (주의 : Ctrl + Z 는 0 Column일 때만 EOF로 간주됨. 두 번째 이후로는 EOF가 아님)

"123 3.14"	"5d%lf"
입력 버퍼에 넣는 과정
1 가져옴. 정수이긴 한데 어떤 정수인지 확신 할 수 없음. 다음을 봐야함.
2 가져옴. 정수이긴 한데 어떤 정수인지 확신 할 수 없음. 다음을 봐야함.
3 가져옴. 정수이긴 한데 어떤 정수인지 확신 할 수 없음. 다음을 봐야함.
' ' 가져옴. 정수가 아님. 123을 입력버퍼에 넣고 ' '는 도로 넣어줌  : unget

"123<EOF>" : EOF를 unget. --> 최종 성공. 이런 case를 주의 해야함.(bug)

형식오류 : fail이지만 뒤에 계속 이어질 여지가 있음
입력오류 : 학과사무실 문닫음


--> 입력성공과 최종성공에 대해서는 데이터 처리가 일어나야 함.
    형식오류, 입력종료, 기록오류에 대헤서는 데이터 처리가 하면 안됨. --> 공통점 : fail() -> true 

그러므로, 입력 상태점검을 가르는 조건으로는 즉, flag는 eof(), bad()이 아닌 *fail()이 적절.

p13
[일반적인 상태 점검 방법]	
cin.fail() == !cin : 이미 만들어져 있음.
!cin == !(cin >> x) : cin >> x의 연산의 결과는 cin

--> 이런 코딩 패턴을 이해하고 *외울 것.

# 코딩에 있어서 단순히 문법만을 아는 것이 아니라 코딩 패턴까지도 알아야 함. 
  --> C언어스럽게 코딩하지 말고 C++스럽게 코딩 할 것. ==> 프로그래밍

p16
오른쪽 코드는 바보같은 코드임.
왼쪽 같이 코딩할 것.

+)
// 바람직
while( scanf() == 1)
while( scanf() == 2)
while( scanf() > 0)

// 비바람직
while( scanf() != 0) : EOF의 경우도 포함해버림

p18 
중요. 그냥 외울것.















